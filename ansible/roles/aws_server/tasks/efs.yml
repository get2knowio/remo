---
# EFS - Elastic File System for persistent home directory

- name: Check if EFS filesystem already exists
  delegate_to: localhost
  become: false
  amazon.aws.efs_info:
    profile: "{{ aws_profile if aws_profile else omit }}"
    access_key: "{{ omit if aws_profile else (aws_access_key_id if aws_access_key_id else omit) }}"
    secret_key: "{{ omit if aws_profile else (aws_secret_access_key if aws_secret_access_key else omit) }}"
    region: "{{ aws_region }}"
    tags:
      Name: "{{ aws_efs_name }}"
  register: existing_efs

- name: Create EFS filesystem
  delegate_to: localhost
  become: false
  community.aws.efs:
    profile: "{{ aws_profile if aws_profile else omit }}"
    access_key: "{{ omit if aws_profile else (aws_access_key_id if aws_access_key_id else omit) }}"
    secret_key: "{{ omit if aws_profile else (aws_secret_access_key if aws_secret_access_key else omit) }}"
    region: "{{ aws_region }}"
    name: "{{ aws_efs_name }}"
    throughput_mode: "{{ aws_efs_throughput_mode }}"
    tags:
      Name: "{{ aws_efs_name }}"
      remo: "true"
      remo_resource_name: "{{ aws_resource_name }}"
    state: present
  register: efs_result
  when: existing_efs.efs | default([]) | length == 0

- name: Set EFS ID fact (new filesystem)
  ansible.builtin.set_fact:
    aws_efs_id: "{{ efs_result.efs.file_system_id }}"
  when: existing_efs.efs | default([]) | length == 0

- name: Set EFS ID fact (existing filesystem)
  ansible.builtin.set_fact:
    aws_efs_id: "{{ existing_efs.efs[0].file_system_id }}"
  when: existing_efs.efs | default([]) | length > 0

- name: Display EFS info
  ansible.builtin.debug:
    msg: "EFS filesystem: {{ aws_efs_name }} ({{ aws_efs_id }})"

- name: Wait for EFS to be available
  delegate_to: localhost
  become: false
  amazon.aws.efs_info:
    profile: "{{ aws_profile if aws_profile else omit }}"
    access_key: "{{ omit if aws_profile else (aws_access_key_id if aws_access_key_id else omit) }}"
    secret_key: "{{ omit if aws_profile else (aws_secret_access_key if aws_secret_access_key else omit) }}"
    region: "{{ aws_region }}"
    id: "{{ aws_efs_id }}"
  register: efs_status
  until: efs_status.efs[0].life_cycle_state | default('creating') == 'available'
  retries: 30
  delay: 10

- name: Create security group for EFS mount targets
  delegate_to: localhost
  become: false
  amazon.aws.ec2_security_group:
    name: "{{ aws_efs_name }}-sg"
    description: "EFS mount target access for remo ({{ aws_resource_name }})"
    vpc_id: "{{ aws_vpc_id }}"
    region: "{{ aws_region }}"
    profile: "{{ aws_profile if aws_profile else omit }}"
    access_key: "{{ omit if aws_profile else (aws_access_key_id if aws_access_key_id else omit) }}"
    secret_key: "{{ omit if aws_profile else (aws_secret_access_key if aws_secret_access_key else omit) }}"
    rules:
      - proto: tcp
        ports:
          - 2049
        group_id: "{{ aws_security_group_id }}"
        rule_desc: "NFS from EC2 security group"
    state: present
    tags:
      Name: "{{ aws_efs_name }}-sg"
      remo: "true"
      remo_resource_name: "{{ aws_resource_name }}"
  register: efs_security_group_result

- name: Set EFS security group ID fact
  ansible.builtin.set_fact:
    aws_efs_security_group_id: "{{ efs_security_group_result.group_id }}"

- name: Get default subnets in VPC
  delegate_to: localhost
  become: false
  amazon.aws.ec2_vpc_subnet_info:
    profile: "{{ aws_profile if aws_profile else omit }}"
    access_key: "{{ omit if aws_profile else (aws_access_key_id if aws_access_key_id else omit) }}"
    secret_key: "{{ omit if aws_profile else (aws_secret_access_key if aws_secret_access_key else omit) }}"
    region: "{{ aws_region }}"
    filters:
      vpc-id: "{{ aws_vpc_id }}"
      default-for-az: "true"
  register: default_subnets

- name: Get existing mount targets
  delegate_to: localhost
  become: false
  community.aws.efs_info:
    profile: "{{ aws_profile if aws_profile else omit }}"
    access_key: "{{ omit if aws_profile else (aws_access_key_id if aws_access_key_id else omit) }}"
    secret_key: "{{ omit if aws_profile else (aws_secret_access_key if aws_secret_access_key else omit) }}"
    region: "{{ aws_region }}"
    id: "{{ aws_efs_id }}"
  register: efs_info_with_targets

- name: Set existing mount target subnets fact
  ansible.builtin.set_fact:
    existing_mount_target_subnets: "{{ efs_info_with_targets.efs[0].mount_targets | default([]) | map(attribute='subnet_id') | list }}"

- name: Create EFS mount targets in each subnet
  delegate_to: localhost
  become: false
  community.aws.efs:
    profile: "{{ aws_profile if aws_profile else omit }}"
    access_key: "{{ omit if aws_profile else (aws_access_key_id if aws_access_key_id else omit) }}"
    secret_key: "{{ omit if aws_profile else (aws_secret_access_key if aws_secret_access_key else omit) }}"
    region: "{{ aws_region }}"
    id: "{{ aws_efs_id }}"
    targets:
      - subnet_id: "{{ item.subnet_id }}"
        security_groups:
          - "{{ aws_efs_security_group_id }}"
    state: present
  loop: "{{ default_subnets.subnets }}"
  when: item.subnet_id not in existing_mount_target_subnets
  register: mount_target_results

- name: Set lifecycle policy for infrequent access
  delegate_to: localhost
  become: false
  ansible.builtin.shell:
    cmd: |
      {{ ansible_playbook_python }} << 'PYTHON'
      import boto3
      {% if aws_profile %}
      session = boto3.Session(profile_name='{{ aws_profile }}', region_name='{{ aws_region }}')
      client = session.client('efs')
      {% elif aws_access_key_id and aws_secret_access_key %}
      client = boto3.client('efs',
          region_name='{{ aws_region }}',
          aws_access_key_id='{{ aws_access_key_id }}',
          aws_secret_access_key='{{ aws_secret_access_key }}'
      )
      {% else %}
      session = boto3.Session(region_name='{{ aws_region }}')
      client = session.client('efs')
      {% endif %}
      client.put_lifecycle_configuration(
          FileSystemId='{{ aws_efs_id }}',
          LifecyclePolicies=[
              {'TransitionToIA': '{{ aws_efs_lifecycle_policy }}'},
              {'TransitionToPrimaryStorageClass': 'AFTER_1_ACCESS'}
          ]
      )
      print('Lifecycle policy set')
      PYTHON
  register: lifecycle_result
  changed_when: "'Lifecycle policy set' in lifecycle_result.stdout | default('')"

---
# Volume setup must happen BEFORE creating the user
# Note: On AWS NVMe instances, /dev/xvdf may appear as /dev/nvme1n1
- name: Check if specified volume device exists
  ansible.builtin.stat:
    path: "{{ remo_volume_device }}"
  register: volume_device_stat
  when: remo_volume_device | length > 0

- name: Check for NVMe device as alternative (AWS)
  ansible.builtin.stat:
    path: /dev/nvme1n1
  register: nvme_device_stat
  when:
    - remo_volume_device | length > 0
    - not (volume_device_stat.stat.exists | default(false))

- name: Set actual volume device path
  ansible.builtin.set_fact:
    actual_volume_device: "{{ remo_volume_device if (volume_device_stat.stat.exists | default(false)) else ('/dev/nvme1n1' if (nvme_device_stat.stat.exists | default(false)) else '') }}"
  when: remo_volume_device | length > 0

- name: Display volume device info
  ansible.builtin.debug:
    msg: "Using volume device: {{ actual_volume_device | default('none') }} (requested: {{ remo_volume_device }})"
  when: remo_volume_device | length > 0

- name: Check if volume is already formatted
  ansible.builtin.command:
    cmd: "blkid {{ actual_volume_device }}"
  register: volume_blkid
  changed_when: false
  failed_when: false
  when:
    - remo_volume_device | length > 0
    - actual_volume_device | default('') | length > 0

- name: Format volume with ext4 filesystem
  ansible.builtin.filesystem:
    fstype: ext4
    dev: "{{ actual_volume_device }}"
  when:
    - remo_volume_device | length > 0
    - actual_volume_device | default('') | length > 0
    - volume_blkid.rc | default(1) != 0

- name: Create temporary mount point for home directory
  ansible.builtin.file:
    path: "/home/{{ remo_user }}"
    state: directory
    mode: '0755'
  when:
    - remo_volume_device | length > 0
    - actual_volume_device | default('') | length > 0

- name: Mount volume as user home directory
  ansible.posix.mount:
    path: "/home/{{ remo_user }}"
    src: "{{ actual_volume_device }}"
    fstype: ext4
    opts: defaults,nofail
    state: mounted
  when:
    - remo_volume_device | length > 0
    - actual_volume_device | default('') | length > 0

- name: Resize filesystem if volume was resized
  ansible.builtin.command:
    cmd: "resize2fs {{ actual_volume_device }}"
  register: resize_result
  changed_when: "'Nothing to do' not in (resize_result.stderr | default(''))"
  when:
    - remo_volume_device | length > 0
    - actual_volume_device | default('') | length > 0

- name: Install figlet for ASCII banners
  ansible.builtin.apt:
    name: figlet
    state: present
    update_cache: true

- name: Check if UID 1000 is taken by another user
  ansible.builtin.command:
    cmd: id -nu 1000
  register: uid_1000_user
  changed_when: false
  failed_when: false

- name: Reassign UID 1000 to remo user
  ansible.builtin.shell: |
    target_user="{{ uid_1000_user.stdout }}"
    new_user="{{ remo_user }}"
    # Change UID from 1000 to 1001 for the existing user
    awk -F: -v OFS=: -v user="$target_user" '$1 == user && $3 == "1000" { $3 = "1001" } 1' /etc/passwd > /etc/passwd.tmp
    cat /etc/passwd.tmp > /etc/passwd
    rm -f /etc/passwd.tmp
    # Update primary group
    groupmod -g 1001 "$target_user" 2>/dev/null || true
    # Create remo user with UID 1000 immediately so sudo keeps working
    useradd -u 1000 -m -s /bin/bash "$new_user"
    # Grant sudo immediately so the Ansible connection (now seen as remo) can escalate
    echo "$new_user ALL=(ALL) NOPASSWD:ALL" > "/etc/sudoers.d/$new_user"
    chmod 440 "/etc/sudoers.d/$new_user"
    # Fix file ownership for displaced user
    find "/home/$target_user" -user 1000 -exec chown 1001 {} + 2>/dev/null || true
  args:
    executable: /bin/bash
  when:
    - uid_1000_user.rc | default(1) == 0
    - uid_1000_user.stdout | default('') != remo_user

- name: Reconnect after UID reassignment
  ansible.builtin.meta: reset_connection

- name: Create remo user with UID 1000 (matches devcontainer vscode user)
  ansible.builtin.user:
    name: "{{ remo_user }}"
    uid: 1000
    shell: /bin/bash
    create_home: true
    state: present

- name: Ensure home directory has correct ownership
  ansible.builtin.file:
    path: "/home/{{ remo_user }}"
    owner: "{{ remo_user }}"
    group: "{{ remo_user }}"
    mode: '0755'
    state: directory

- name: Fix ownership of all home directory contents
  ansible.builtin.file:
    path: "/home/{{ remo_user }}"
    owner: "{{ remo_user }}"
    group: "{{ remo_user }}"
    recurse: true

- name: Create .ssh directory for remo user
  ansible.builtin.file:
    path: "/home/{{ remo_user }}/.ssh"
    state: directory
    owner: "{{ remo_user }}"
    group: "{{ remo_user }}"
    mode: '0700'

- name: Check if ubuntu user has authorized_keys (AWS EC2 injects keys to ubuntu)
  ansible.builtin.stat:
    path: /home/ubuntu/.ssh/authorized_keys
  register: ubuntu_authorized_keys

- name: Check if root has authorized_keys (Hetzner injects keys to root)
  ansible.builtin.stat:
    path: /root/.ssh/authorized_keys
  register: root_authorized_keys

# Prefer ubuntu's keys over root's - on EC2 root's authorized_keys contains
# a forced command that rejects login, while ubuntu's has the actual key
- name: Copy authorized_keys from ubuntu to remo user (AWS EC2)
  ansible.builtin.copy:
    src: /home/ubuntu/.ssh/authorized_keys
    dest: "/home/{{ remo_user }}/.ssh/authorized_keys"
    remote_src: true
    owner: "{{ remo_user }}"
    group: "{{ remo_user }}"
    mode: '0600'
  when:
    - ubuntu_authorized_keys.stat.exists | default(false)
    - ubuntu_authorized_keys.stat.size | default(0) > 0

- name: Copy authorized_keys from root to remo user (Hetzner)
  ansible.builtin.copy:
    src: /root/.ssh/authorized_keys
    dest: "/home/{{ remo_user }}/.ssh/authorized_keys"
    remote_src: true
    owner: "{{ remo_user }}"
    group: "{{ remo_user }}"
    mode: '0600'
  when:
    - not (ubuntu_authorized_keys.stat.exists | default(false)) or (ubuntu_authorized_keys.stat.size | default(0) == 0)
    - root_authorized_keys.stat.exists | default(false)
    - root_authorized_keys.stat.size | default(0) > 0

- name: Add remo user to docker group
  ansible.builtin.user:
    name: "{{ remo_user }}"
    groups: docker
    append: true

- name: Configure passwordless sudo for remo user
  ansible.builtin.lineinfile:
    path: /etc/sudoers.d/{{ remo_user }}
    line: "{{ remo_user }} ALL=(ALL) NOPASSWD:ALL"
    create: true
    mode: '0440'
    validate: 'visudo -cf %s'

- name: Create devcontainer mount directories
  ansible.builtin.file:
    path: "/home/{{ remo_user }}/{{ item }}"
    state: directory
    owner: "{{ remo_user }}"
    group: "{{ remo_user }}"
    mode: '0755'
  loop:
    - .codex
    - .config/opencode
    - .config/gh
    - .coderabbit
    - .local/bin

- name: Create projects directory
  ansible.builtin.file:
    path: "{{ dev_workspace_dir }}"
    state: directory
    owner: "{{ remo_user }}"
    group: "{{ remo_user }}"
    mode: '0755'

- name: Ensure ~/.local/bin is in PATH via .bashrc
  ansible.builtin.blockinfile:
    path: "/home/{{ remo_user }}/.bashrc"
    marker: "# {mark} ANSIBLE MANAGED BLOCK - PATH"
    block: |
      # Add ~/.local/bin to PATH if it exists
      if [ -d "$HOME/.local/bin" ] ; then
          PATH="$HOME/.local/bin:$PATH"
      fi
    create: true
    owner: "{{ remo_user }}"
    group: "{{ remo_user }}"
    mode: '0644'

- name: Configure terminal type fallback for unknown terminals
  ansible.builtin.blockinfile:
    path: "/home/{{ remo_user }}/.bashrc"
    marker: "# {mark} ANSIBLE MANAGED BLOCK - TERM FALLBACK"
    block: |
      # Fallback for unknown terminal types (e.g., xterm-ghostty)
      # This prevents "unknown terminal type" errors when using modern terminals
      if ! infocmp "$TERM" &>/dev/null 2>&1; then
          export TERM=xterm-256color
      fi
    create: true
    owner: "{{ remo_user }}"
    group: "{{ remo_user }}"
    mode: '0644'
    insertbefore: "# {mark} ANSIBLE MANAGED BLOCK - PROJECT MENU"

- name: Configure project-menu auto-start on SSH login
  ansible.builtin.blockinfile:
    path: "/home/{{ remo_user }}/.bashrc"
    marker: "# {mark} ANSIBLE MANAGED BLOCK - PROJECT MENU"
    block: |
      # Auto-start project-menu on SSH login
      # Only trigger when:
      #   - Shell is interactive
      #   - Session is SSH (SSH_TTY or SSH_CONNECTION is set)
      #   - Not already inside a zellij session
      #   - Not already inside a devcontainer
      if [[ $- == *i* ]] && [[ -n "$SSH_TTY" || -n "$SSH_CONNECTION" ]] && [[ -z "$ZELLIJ" ]] && [[ -z "$REMOTE_CONTAINERS" ]]; then
          project-menu
          # Exit code 0 = user chose "Exit to shell", stay in shell
          # Exit code 1 = user pressed Ctrl+C or selected project, exit
          if [[ $? -ne 0 ]]; then
              exit
          fi
      fi
    create: true
    owner: "{{ remo_user }}"
    group: "{{ remo_user }}"
    mode: '0644'
    insertafter: EOF

- name: Configure devcontainer auto-start inside zellij sessions
  ansible.builtin.blockinfile:
    path: "/home/{{ remo_user }}/.bashrc"
    marker: "# {mark} ANSIBLE MANAGED BLOCK - DEVCONTAINER AUTO-START"
    block: |
      # Auto-start devcontainer when inside a zellij session for a devcontainer project
      # Only trigger when:
      #   - Shell is interactive
      #   - Inside zellij (ZELLIJ_SESSION_NAME is set)
      #   - Not already inside a devcontainer
      if [[ $- == *i* ]] && [[ -n "$ZELLIJ_SESSION_NAME" ]] && [[ -z "$REMOTE_CONTAINERS" ]]; then
          _project_dir="{{ dev_workspace_dir }}/$ZELLIJ_SESSION_NAME"
          if [[ -d "$_project_dir/.devcontainer" ]] || [[ -f "$_project_dir/.devcontainer.json" ]]; then
              cd "$_project_dir"
              
              # Check if devcontainer config has changed and needs rebuild
              _hash_dir="$HOME/.cache/devcontainer-hashes"
              _hash_file="$_hash_dir/$ZELLIJ_SESSION_NAME"
              _rebuild_flag=""
              
              # Compute hash of devcontainer config files
              _current_hash=$(cat "$_project_dir/.devcontainer/devcontainer.json" \
                  "$_project_dir/.devcontainer.json" \
                  "$_project_dir/.devcontainer/Dockerfile" \
                  "$_project_dir/.devcontainer/docker-compose.yml" \
                  2>/dev/null | sha256sum | cut -d' ' -f1)
              
              # Compare with stored hash
              mkdir -p "$_hash_dir"
              if [[ -f "$_hash_file" ]]; then
                  _stored_hash=$(cat "$_hash_file")
                  if [[ "$_current_hash" != "$_stored_hash" ]]; then
                      echo "Devcontainer config changed, rebuilding..."
                      _rebuild_flag="--remove-existing-container"
                  fi
              fi
              
              # Also check for manual rebuild request
              if [[ -f "$_project_dir/.devcontainer-rebuild" ]]; then
                  echo "Manual rebuild requested..."
                  _rebuild_flag="--remove-existing-container"
                  rm -f "$_project_dir/.devcontainer-rebuild"
              fi
              
              echo "Starting devcontainer for $ZELLIJ_SESSION_NAME..."
              if ! devcontainer up --workspace-folder "$_project_dir" $_rebuild_flag; then
                  echo ""
                  echo "devcontainer up failed. [Press any key to continue]"
                  read -n 1 -s -r
                  exit 1
              fi

              # Store current hash after successful start
              echo "$_current_hash" > "$_hash_file"

              echo ""
              echo "Entering devcontainer (exit to return to host shell)..."
              echo ""

              # Run devcontainer shell (not exec, so we can stop container after)
              if ! devcontainer exec --workspace-folder "$_project_dir" /bin/bash -c \
                  'if command -v zsh &> /dev/null; then exec zsh; else exec bash; fi'; then
                  echo ""
                  echo "devcontainer exec failed. [Press any key to continue]"
                  read -n 1 -s -r
              fi

              # After exiting devcontainer, stop the container to free resources
              echo ""
              echo "Stopping devcontainer..."
              _container_id=$(docker ps -q --filter "label=devcontainer.local_folder=$_project_dir")
              if [[ -n "$_container_id" ]]; then
                  docker stop "$_container_id" >/dev/null 2>&1 || true
              fi
              
              # Exit the zellij session to return to project menu
              exit 0
          fi
          unset _project_dir _hash_dir _hash_file _rebuild_flag _current_hash _stored_hash _container_id
      fi
    create: true
    owner: "{{ remo_user }}"
    group: "{{ remo_user }}"
    mode: '0644'
    insertafter: EOF

- name: Ensure .bash_profile sources .bashrc for login shells
  ansible.builtin.blockinfile:
    path: "/home/{{ remo_user }}/.bash_profile"
    marker: "# {mark} ANSIBLE MANAGED BLOCK - BASHRC"
    block: |
      # Fallback for unknown terminal types (e.g., xterm-ghostty)
      # This MUST happen before sourcing .bashrc or any interactive commands
      if ! infocmp "$TERM" &>/dev/null 2>&1; then
          export TERM=xterm-256color
      fi

      # Source .bashrc for interactive login shells (like SSH)
      if [ -f "$HOME/.bashrc" ]; then
          source "$HOME/.bashrc"
      fi
    create: true
    owner: "{{ remo_user }}"
    group: "{{ remo_user }}"
    mode: '0644'

- name: Install devshell helper script
  ansible.builtin.template:
    src: devshell.sh.j2
    dest: "/home/{{ remo_user }}/.local/bin/devshell"
    owner: "{{ remo_user }}"
    group: "{{ remo_user }}"
    mode: '0755'

- name: Install project-menu script
  ansible.builtin.template:
    src: project-menu.sh.j2
    dest: "/home/{{ remo_user }}/.local/bin/project-menu"
    owner: "{{ remo_user }}"
    group: "{{ remo_user }}"
    mode: '0755'

- name: Verify remo user exists
  ansible.builtin.command: id {{ remo_user }}
  register: user_setup_user_info
  changed_when: false

- name: Display user information
  ansible.builtin.debug:
    msg: "User created: {{ user_setup_user_info.stdout }}"

---
# Volume setup must happen BEFORE creating the user
- name: Check if volume device exists
  ansible.builtin.stat:
    path: "{{ remo_volume_device }}"
  register: volume_device_stat
  when: remo_volume_device | length > 0

- name: Check if volume is already formatted
  ansible.builtin.command:
    cmd: "blkid {{ remo_volume_device }}"
  register: volume_blkid
  changed_when: false
  failed_when: false
  when:
    - remo_volume_device | length > 0
    - volume_device_stat.stat.exists | default(false)

- name: Format volume with ext4 filesystem
  ansible.builtin.filesystem:
    fstype: ext4
    dev: "{{ remo_volume_device }}"
  when:
    - remo_volume_device | length > 0
    - volume_device_stat.stat.exists | default(false)
    - volume_blkid.rc != 0

- name: Create temporary mount point for home directory
  ansible.builtin.file:
    path: "/home/{{ remo_user }}"
    state: directory
    mode: '0755'
  when:
    - remo_volume_device | length > 0
    - volume_device_stat.stat.exists | default(false)

- name: Mount volume as user home directory
  ansible.posix.mount:
    path: "/home/{{ remo_user }}"
    src: "{{ remo_volume_device }}"
    fstype: ext4
    opts: defaults,nofail
    state: mounted
  when:
    - remo_volume_device | length > 0
    - volume_device_stat.stat.exists | default(false)

- name: Resize filesystem if volume was resized
  ansible.builtin.command:
    cmd: "resize2fs {{ remo_volume_device }}"
  register: resize_result
  changed_when: "'Nothing to do' not in resize_result.stderr"
  when:
    - remo_volume_device | length > 0
    - volume_device_stat.stat.exists | default(false)

# EFS Setup (AWS) - alternative to block volume
- name: Install NFS utilities for EFS mounting
  ansible.builtin.apt:
    name:
      - nfs-common
      - binutils
    state: present
    update_cache: true
  when: remo_efs_id | default('') | length > 0

- name: Install amazon-efs-utils (with stunnel for TLS)
  ansible.builtin.apt:
    name: stunnel4
    state: present
  when: remo_efs_id | default('') | length > 0

- name: Create temporary mount point for EFS home directory
  ansible.builtin.file:
    path: "/home/{{ remo_user }}"
    state: directory
    mode: '0755'
  when: remo_efs_id | default('') | length > 0

- name: Mount EFS as user home directory
  ansible.posix.mount:
    path: "/home/{{ remo_user }}"
    src: "{{ remo_efs_id }}.efs.{{ remo_efs_region }}.amazonaws.com:/"
    fstype: nfs4
    opts: "nfsvers=4.1,rsize=1048576,wsize=1048576,hard,timeo=600,retrans=2,noresvport,_netdev"
    state: mounted
  when: remo_efs_id | default('') | length > 0

- name: Install figlet for ASCII banners
  ansible.builtin.apt:
    name: figlet
    state: present
    update_cache: true

- name: Create remo user
  ansible.builtin.user:
    name: "{{ remo_user }}"
    shell: /bin/bash
    create_home: true
    state: present

- name: Ensure home directory has correct ownership
  ansible.builtin.file:
    path: "/home/{{ remo_user }}"
    owner: "{{ remo_user }}"
    group: "{{ remo_user }}"
    mode: '0755'
    state: directory

- name: Fix ownership of all home directory contents
  ansible.builtin.file:
    path: "/home/{{ remo_user }}"
    owner: "{{ remo_user }}"
    group: "{{ remo_user }}"
    recurse: true

- name: Create .ssh directory for remo user
  ansible.builtin.file:
    path: "/home/{{ remo_user }}/.ssh"
    state: directory
    owner: "{{ remo_user }}"
    group: "{{ remo_user }}"
    mode: '0700'

- name: Check if root has authorized_keys (Hetzner injects keys to root)
  ansible.builtin.stat:
    path: /root/.ssh/authorized_keys
  register: root_authorized_keys

- name: Check if ubuntu user has authorized_keys (AWS EC2 injects keys to ubuntu)
  ansible.builtin.stat:
    path: /home/ubuntu/.ssh/authorized_keys
  register: ubuntu_authorized_keys

- name: Copy authorized_keys from root to remo user
  ansible.builtin.copy:
    src: /root/.ssh/authorized_keys
    dest: "/home/{{ remo_user }}/.ssh/authorized_keys"
    remote_src: true
    owner: "{{ remo_user }}"
    group: "{{ remo_user }}"
    mode: '0600'
  when:
    - root_authorized_keys.stat.exists | default(false)
    - root_authorized_keys.stat.size | default(0) > 0

- name: Copy authorized_keys from ubuntu to remo user (AWS EC2)
  ansible.builtin.copy:
    src: /home/ubuntu/.ssh/authorized_keys
    dest: "/home/{{ remo_user }}/.ssh/authorized_keys"
    remote_src: true
    owner: "{{ remo_user }}"
    group: "{{ remo_user }}"
    mode: '0600'
  when:
    - not (root_authorized_keys.stat.exists | default(false)) or (root_authorized_keys.stat.size | default(0) == 0)
    - ubuntu_authorized_keys.stat.exists | default(false)
    - ubuntu_authorized_keys.stat.size | default(0) > 0

- name: Add remo user to docker group
  ansible.builtin.user:
    name: "{{ remo_user }}"
    groups: docker
    append: true

- name: Configure passwordless sudo for remo user
  ansible.builtin.lineinfile:
    path: /etc/sudoers.d/{{ remo_user }}
    line: "{{ remo_user }} ALL=(ALL) NOPASSWD:ALL"
    create: true
    mode: '0440'
    validate: 'visudo -cf %s'

- name: Create devcontainer mount directories
  ansible.builtin.file:
    path: "/home/{{ remo_user }}/{{ item }}"
    state: directory
    owner: "{{ remo_user }}"
    group: "{{ remo_user }}"
    mode: '0755'
  loop:
    - .codex
    - .config/opencode
    - .config/gh
    - .coderabbit
    - .local/bin

- name: Create projects directory
  ansible.builtin.file:
    path: "{{ dev_workspace_dir }}"
    state: directory
    owner: "{{ remo_user }}"
    group: "{{ remo_user }}"
    mode: '0755'

- name: Ensure ~/.local/bin is in PATH via .bashrc
  ansible.builtin.blockinfile:
    path: "/home/{{ remo_user }}/.bashrc"
    marker: "# {mark} ANSIBLE MANAGED BLOCK - PATH"
    block: |
      # Add ~/.local/bin to PATH if it exists
      if [ -d "$HOME/.local/bin" ] ; then
          PATH="$HOME/.local/bin:$PATH"
      fi
    create: true
    owner: "{{ remo_user }}"
    group: "{{ remo_user }}"
    mode: '0644'

- name: Configure terminal type fallback for unknown terminals
  ansible.builtin.blockinfile:
    path: "/home/{{ remo_user }}/.bashrc"
    marker: "# {mark} ANSIBLE MANAGED BLOCK - TERM FALLBACK"
    block: |
      # Fallback for unknown terminal types (e.g., xterm-ghostty)
      # This prevents "unknown terminal type" errors when using modern terminals
      if ! infocmp "$TERM" &>/dev/null 2>&1; then
          export TERM=xterm-256color
      fi
    create: true
    owner: "{{ remo_user }}"
    group: "{{ remo_user }}"
    mode: '0644'
    insertbefore: "# {mark} ANSIBLE MANAGED BLOCK - PROJECT MENU"

- name: Configure project-menu auto-start on SSH login
  ansible.builtin.blockinfile:
    path: "/home/{{ remo_user }}/.bashrc"
    marker: "# {mark} ANSIBLE MANAGED BLOCK - PROJECT MENU"
    block: |
      # Auto-start project-menu on SSH login
      # Only trigger when:
      #   - Shell is interactive
      #   - Session is SSH (SSH_TTY or SSH_CONNECTION is set)
      #   - Not already inside a zellij session
      #   - Not already inside a devcontainer
      if [[ $- == *i* ]] && [[ -n "$SSH_TTY" || -n "$SSH_CONNECTION" ]] && [[ -z "$ZELLIJ" ]] && [[ -z "$REMOTE_CONTAINERS" ]]; then
          project-menu
          # Exit code 0 = user chose "Exit to shell", stay in shell
          # Exit code 1 = user pressed Ctrl+C or selected project, exit
          if [[ $? -ne 0 ]]; then
              exit
          fi
      fi
    create: true
    owner: "{{ remo_user }}"
    group: "{{ remo_user }}"
    mode: '0644'
    insertafter: EOF

- name: Configure devcontainer auto-start inside zellij sessions
  ansible.builtin.blockinfile:
    path: "/home/{{ remo_user }}/.bashrc"
    marker: "# {mark} ANSIBLE MANAGED BLOCK - DEVCONTAINER AUTO-START"
    block: |
      # Auto-start devcontainer when inside a zellij session for a devcontainer project
      # Only trigger when:
      #   - Shell is interactive
      #   - Inside zellij (ZELLIJ_SESSION_NAME is set)
      #   - Not already inside a devcontainer
      if [[ $- == *i* ]] && [[ -n "$ZELLIJ_SESSION_NAME" ]] && [[ -z "$REMOTE_CONTAINERS" ]]; then
          _project_dir="{{ dev_workspace_dir }}/$ZELLIJ_SESSION_NAME"
          if [[ -d "$_project_dir/.devcontainer" ]] || [[ -f "$_project_dir/.devcontainer.json" ]]; then
              cd "$_project_dir"
              
              # Check if devcontainer config has changed and needs rebuild
              _hash_dir="$HOME/.cache/devcontainer-hashes"
              _hash_file="$_hash_dir/$ZELLIJ_SESSION_NAME"
              _rebuild_flag=""
              
              # Compute hash of devcontainer config files
              _current_hash=$(cat "$_project_dir/.devcontainer/devcontainer.json" \
                  "$_project_dir/.devcontainer.json" \
                  "$_project_dir/.devcontainer/Dockerfile" \
                  "$_project_dir/.devcontainer/docker-compose.yml" \
                  2>/dev/null | sha256sum | cut -d' ' -f1)
              
              # Compare with stored hash
              mkdir -p "$_hash_dir"
              if [[ -f "$_hash_file" ]]; then
                  _stored_hash=$(cat "$_hash_file")
                  if [[ "$_current_hash" != "$_stored_hash" ]]; then
                      echo "Devcontainer config changed, rebuilding..."
                      _rebuild_flag="--remove-existing-container"
                  fi
              fi
              
              # Also check for manual rebuild request
              if [[ -f "$_project_dir/.devcontainer-rebuild" ]]; then
                  echo "Manual rebuild requested..."
                  _rebuild_flag="--remove-existing-container"
                  rm -f "$_project_dir/.devcontainer-rebuild"
              fi
              
              echo "Starting devcontainer for $ZELLIJ_SESSION_NAME..."
              if ! devcontainer up --workspace-folder "$_project_dir" $_rebuild_flag; then
                  echo ""
                  echo "devcontainer up failed. [Press any key to continue]"
                  read -n 1 -s -r
                  exit 1
              fi

              # Store current hash after successful start
              echo "$_current_hash" > "$_hash_file"

              echo ""
              echo "Entering devcontainer (exit to return to host shell)..."
              echo ""

              # Run devcontainer shell (not exec, so we can stop container after)
              if ! devcontainer exec --workspace-folder "$_project_dir" /bin/bash -c \
                  'if command -v zsh &> /dev/null; then exec zsh; else exec bash; fi'; then
                  echo ""
                  echo "devcontainer exec failed. [Press any key to continue]"
                  read -n 1 -s -r
              fi

              # After exiting devcontainer, stop the container to free resources
              echo ""
              echo "Stopping devcontainer..."
              _container_id=$(docker ps -q --filter "label=devcontainer.local_folder=$_project_dir")
              if [[ -n "$_container_id" ]]; then
                  docker stop "$_container_id" >/dev/null 2>&1 || true
              fi
              
              # Exit the zellij session to return to project menu
              exit 0
          fi
          unset _project_dir _hash_dir _hash_file _rebuild_flag _current_hash _stored_hash _container_id
      fi
    create: true
    owner: "{{ remo_user }}"
    group: "{{ remo_user }}"
    mode: '0644'
    insertafter: EOF

- name: Ensure .bash_profile sources .bashrc for login shells
  ansible.builtin.blockinfile:
    path: "/home/{{ remo_user }}/.bash_profile"
    marker: "# {mark} ANSIBLE MANAGED BLOCK - BASHRC"
    block: |
      # Debug logging for SSH login
      echo "[DEBUG] .bash_profile starting" >> /tmp/shell-debug.log
      echo "[DEBUG] TERM=$TERM" >> /tmp/shell-debug.log
      
      # Fallback for unknown terminal types (e.g., xterm-ghostty)
      # This MUST happen before sourcing .bashrc or any interactive commands
      if ! infocmp "$TERM" &>/dev/null 2>&1; then
          echo "[DEBUG] TERM '$TERM' not recognized, falling back to xterm-256color" >> /tmp/shell-debug.log
          export TERM=xterm-256color
      fi
      echo "[DEBUG] TERM after fix=$TERM" >> /tmp/shell-debug.log
      
      # Source .bashrc for interactive login shells (like SSH)
      if [ -f "$HOME/.bashrc" ]; then
          echo "[DEBUG] Sourcing .bashrc" >> /tmp/shell-debug.log
          source "$HOME/.bashrc"
      fi
      echo "[DEBUG] .bash_profile done" >> /tmp/shell-debug.log
    create: true
    owner: "{{ remo_user }}"
    group: "{{ remo_user }}"
    mode: '0644'

- name: Install devshell helper script
  ansible.builtin.template:
    src: devshell.sh.j2
    dest: "/home/{{ remo_user }}/.local/bin/devshell"
    owner: "{{ remo_user }}"
    group: "{{ remo_user }}"
    mode: '0755'

- name: Install project-menu script
  ansible.builtin.template:
    src: project-menu.sh.j2
    dest: "/home/{{ remo_user }}/.local/bin/project-menu"
    owner: "{{ remo_user }}"
    group: "{{ remo_user }}"
    mode: '0755'

- name: Verify remo user exists
  ansible.builtin.command: id {{ remo_user }}
  register: user_setup_user_info
  changed_when: false

- name: Display user information
  ansible.builtin.debug:
    msg: "User created: {{ user_setup_user_info.stdout }}"

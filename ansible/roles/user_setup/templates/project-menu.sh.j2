#!/bin/bash
# project-menu - TUI menu for selecting/managing project zellij sessions
# Managed by Ansible - do not edit manually

set -e

PROJECTS_DIR="{{ dev_workspace_dir }}"
{% if remo_version %}
REMO_VERSION="{{ remo_version }}"
{% else %}
REMO_VERSION=""
{% endif %}
UPDATE_CACHE_FILE="$HOME/.cache/remo/latest-version"
UPDATE_CACHE_MAX_AGE=86400  # 24 hours in seconds

# Refresh version cache in background (non-blocking)
refresh_version_cache() {
    local latest
    latest=$(curl -fsSL --max-time 5 \
        "https://api.github.com/repos/get2knowio/remo/releases?per_page=10" 2>/dev/null | \
        python3 -c "
import sys, json
try:
    releases = json.load(sys.stdin)
    for r in releases:
        if not r.get('prerelease') and not r.get('draft'):
            tag = r.get('tag_name', '')
            if '-rc' not in tag and '-beta' not in tag and '-alpha' not in tag:
                print(tag.lstrip('v'))
                break
except: pass
" 2>/dev/null)

    [ -n "$latest" ] && echo "$latest" > "$UPDATE_CACHE_FILE"
}

# Get latest remo version from GitHub (cached)
get_cached_latest_version() {
    local cache_dir="$HOME/.cache/remo"
    mkdir -p "$cache_dir"

    # Check if cache exists and is fresh
    if [ -f "$UPDATE_CACHE_FILE" ]; then
        local cache_age=$(($(date +%s) - $(stat -c %Y "$UPDATE_CACHE_FILE" 2>/dev/null || echo 0)))
        if [ "$cache_age" -lt "$UPDATE_CACHE_MAX_AGE" ]; then
            cat "$UPDATE_CACHE_FILE"
            return
        fi
    fi

    # Cache is stale or missing - trigger background refresh
    refresh_version_cache &

    # Return cached value if exists (even if stale), otherwise empty
    [ -f "$UPDATE_CACHE_FILE" ] && cat "$UPDATE_CACHE_FILE"
}

# Get version display string with optional update indicator
get_version_display() {
    local current="${REMO_VERSION:-}"

    # If no version configured, return empty
    [ -z "$current" ] && return

    local latest
    latest=$(get_cached_latest_version)

    if [ -n "$latest" ] && [ "$latest" != "$current" ]; then
        echo "v${current} → v${latest}"
    else
        echo "v${current}"
    fi
}

# Get list of active zellij sessions (excludes EXITED sessions)
get_active_sessions() {
    if command -v zellij &> /dev/null; then
        # Strip ANSI color codes, exclude EXITED sessions, and get session names
        zellij list-sessions 2>/dev/null | sed 's/\x1b\[[0-9;]*m//g' | grep -v 'EXITED' | awk '{print $1}' || true
    fi
}

# Clean up exited zellij sessions
cleanup_exited_sessions() {
    if command -v zellij &> /dev/null; then
        # Get list of exited sessions and delete them
        local exited_sessions
        exited_sessions=$(zellij list-sessions 2>/dev/null | sed 's/\x1b\[[0-9;]*m//g' | grep 'EXITED' | awk '{print $1}' || true)
        for session in $exited_sessions; do
            [ -n "$session" ] && zellij delete-session "$session" &>/dev/null || true
        done
    fi
}

# Get list of project directories
get_project_dirs() {
    if [ -d "$PROJECTS_DIR" ]; then
        find "$PROJECTS_DIR" -maxdepth 1 -mindepth 1 -type d -exec basename {} \; 2>/dev/null | sort
    fi
}

# Get git status indicators for a project directory
# Returns: string with status symbols (e.g., "● ⇡" or "●" or "⇡" or "")
get_git_status_indicators() {
    local project_dir="$1"
    local indicators=""

    # Skip if not a git repo
    [ -d "$project_dir/.git" ] || return

    # Check for uncommitted changes (modified, staged, or untracked)
    if ! git -C "$project_dir" diff --quiet HEAD 2>/dev/null || \
       [ -n "$(git -C "$project_dir" status --porcelain 2>/dev/null)" ]; then
        indicators="●"
    fi

    # Check for unpushed commits (ahead of upstream)
    local ahead
    ahead=$(git -C "$project_dir" rev-list --count @{upstream}..HEAD 2>/dev/null || echo "0")
    if [ "$ahead" -gt 0 ]; then
        [ -n "$indicators" ] && indicators="$indicators "
        indicators="${indicators}⇡"
    fi

    echo "$indicators"
}

# Build menu options
build_menu_options() {
    local active_sessions
    local project_dirs
    local options=()

    # Clean up any exited sessions first
    cleanup_exited_sessions

    # Get active sessions as array
    mapfile -t active_sessions < <(get_active_sessions)

    # Get all project directories
    mapfile -t project_dirs < <(get_project_dirs)

    # Create associative array for quick lookup of active sessions
    declare -A active_map
    for session in "${active_sessions[@]}"; do
        [ -n "$session" ] && active_map["$session"]=1
    done

    # Build options: show projects with git status and active indicators
    for dir in "${project_dirs[@]}"; do
        local indicators=""

        # Add git status indicators
        local git_status
        git_status=$(get_git_status_indicators "$PROJECTS_DIR/$dir")
        [ -n "$git_status" ] && indicators="$git_status"

        # Add active indicator if session is running
        if [ -n "${active_map[$dir]}" ]; then
            [ -n "$indicators" ] && indicators="$indicators "
            indicators="${indicators}⚡"
        fi

        # Build display name with colored indicators
        if [ -n "$indicators" ]; then
            # Color the indicators: ● yellow, ⇡ cyan, ⚡ green
            local colored
            colored=$(echo "$indicators" | sed \
                -e 's/●/\\033[33m●\\033[0m/g' \
                -e 's/⇡/\\033[36m⇡\\033[0m/g' \
                -e 's/⚡/\\033[32m⚡\\033[0m/g')
            options+=("$(printf '%s %b' "$dir" "$colored")")
        else
            options+=("$dir")
        fi
    done

    # Special options
    options+=("[Clone new repo]")
    options+=("[Exit to shell]")

    printf '%s\n' "${options[@]}"
}

# Generate the banner text
get_banner() {
    local banner=""
    if command -v figlet &> /dev/null; then
        # Trim leading/trailing blank lines from figlet output
        banner=$(figlet -f slant "remo" 2>/dev/null | sed '/^[[:space:]]*$/d')
    fi
    
    if [ -z "$banner" ]; then
        # Fallback ASCII art if figlet not installed or failed
        banner='   ____ ___ _ __ ___   ___  
  | __// _ \  _ ` _ \ / _ \ 
  | | |  __/ | | | | | (_) |
  |_|  \___|_| |_| |_|\___/ '
    fi
    echo "$banner"
}

# Display menu and get selection
show_menu() {
    local options
    local header
    options=$(build_menu_options)
    
    # Count the number of project entries (excluding Clone and Exit options)
    local project_count
    project_count=$(echo "$options" | grep -c -v '^\[' || true)
    
    # Build header with banner and version display
    local version_display
    version_display=$(get_version_display)
    if [ -n "$version_display" ]; then
        header=$(printf '\033[36m%s\033[0m\n\n  \033[90m[ Remote Coding Server %s ]\033[0m\n\nSelect a project (1-9, ↑↓, Enter | c=clone, x=exit):' "$(get_banner)" "$version_display")
    else
        header=$(printf '\033[36m%s\033[0m\n\n  \033[90m[ Remote Coding Server ]\033[0m\n\nSelect a project (1-9, ↑↓, Enter | c=clone, x=exit):' "$(get_banner)")
    fi

    echo "$options" | fzf --reverse --no-info \
        --header="$header" \
        --pointer=">" \
        --prompt="" \
        --color="header:bold" \
        --ansi \
        --bind="1:pos(1)+accept,2:pos(2)+accept,3:pos(3)+accept,4:pos(4)+accept,5:pos(5)+accept" \
        --bind="6:pos(6)+accept,7:pos(7)+accept,8:pos(8)+accept,9:pos(9)+accept" \
        --bind="c:pos($((project_count + 1)))+accept" \
        --bind="x:pos($((project_count + 2)))+accept"
}

# Ensure GitHub CLI is authenticated, prompting login if needed
ensure_gh_auth() {
    if ! command -v gh &> /dev/null; then
        return 1
    fi

    if gh auth status &>/dev/null; then
        return 0
    fi

    echo "" >&2
    echo "GitHub CLI is not authenticated." >&2
    echo "Logging in lets you clone private repos and push changes." >&2
    echo "" >&2

    if gh auth login >&2; then
        echo "" >&2
        echo "GitHub authentication successful!" >&2
        echo "" >&2
        return 0
    else
        echo "GitHub login skipped or failed. Public repos can still be cloned." >&2
        echo "" >&2
        return 1
    fi
}

# Handle cloning a new repo
# Note: User-facing messages go to stderr, only repo name goes to stdout
handle_clone() {
    local repo_url
    local repo_name

    # Prompt gh login if not authenticated (non-blocking - clone can still work for public repos)
    ensure_gh_auth

    echo "" >&2
    echo -n "Enter GitHub repo (owner/repo or URL): " >&2
    read -r repo_url

    if [ -z "$repo_url" ]; then
        echo "Cancelled." >&2
        return 1
    fi

    # Extract repo name from URL or owner/repo format
    repo_name=$(basename "$repo_url" .git)

    local target_dir="$PROJECTS_DIR/$repo_name"

    if [ -d "$target_dir" ]; then
        echo "Error: Directory $target_dir already exists" >&2
        sleep 2
        return 1
    fi

    echo "Cloning $repo_url to $target_dir..." >&2

    # Try gh first (better auth), fall back to git clone
    local clone_ok=false
    if command -v gh &> /dev/null && gh auth status &>/dev/null; then
        if gh repo clone "$repo_url" "$target_dir" >&2; then
            clone_ok=true
        fi
    fi

    if [ "$clone_ok" = false ]; then
        if ! git clone "$repo_url" "$target_dir" >&2; then
            echo "Error: Clone failed" >&2
            sleep 2
            return 1
        fi
    fi

    echo "Cloned successfully!" >&2
    sleep 1

    # Return the repo name to stdout (for capture by caller)
    echo "$repo_name"
}

# Launch or attach to a zellij session for a project
launch_session() {
    local project_name="$1"
    local project_dir="$PROJECTS_DIR/$project_name"

    if [ ! -d "$project_dir" ]; then
        echo "Error: Project directory not found: $project_dir"
        sleep 2
        return 1
    fi

    echo "Launching $project_name..."

    # Clean up any exited session with this name before attaching
    if zellij list-sessions 2>/dev/null | sed 's/\x1b\[[0-9;]*m//g' | grep -q "^$project_name.*EXITED"; then
        zellij delete-session "$project_name" 2>/dev/null || true
    fi

    # Always use zellij for every project
    # The session starts in the project directory
    # If it has a devcontainer, the shell inside will handle starting it
    cd "$project_dir"
    
    # Try to attach, and if it fails due to corrupted session layout, clean up and retry
    if ! zellij attach --create "$project_name" 2>&1; then
        echo "Session may be corrupted, cleaning up and retrying..."
        # Kill any orphaned zellij processes for this session
        zellij kill-session "$project_name" 2>/dev/null || true
        zellij delete-session "$project_name" 2>/dev/null || true
        # Remove corrupted session cache files
        rm -rf "$HOME/.cache/zellij"/*/session_info/"$project_name" 2>/dev/null || true
        # Retry creating a fresh session
        zellij attach --create "$project_name"
    fi
}

# Main menu loop
main() {
    # Verify fzf is available
    if ! command -v fzf &> /dev/null; then
        echo "Error: fzf is not installed."
        exit 1
    fi

    while true; do
        local selection
        selection=$(show_menu) || {
            # User pressed Ctrl+C or Escape - exit with code 1
            echo ""
            exit 1
        }

        case "$selection" in
            "[Clone new repo]")
                local new_repo
                if new_repo=$(handle_clone); then
                    # Launch session for newly cloned repo
                    launch_session "$new_repo"
                fi
                ;;
            "[Exit to shell]")
                echo ""
                echo "Exiting to shell. Run 'project-menu' to return."
                exit 0
                ;;
            *)
                # Extract project name (strip ANSI codes and status indicators)
                local project_name
                # Remove ANSI escape codes, then strip trailing indicators (● ⇡ ⚡ and spaces)
                project_name=$(echo "$selection" | sed 's/\x1b\[[0-9;]*m//g' | sed -E 's/ [●⇡⚡ ]+$//')
                launch_session "$project_name"
                ;;
        esac

        # After detaching from zellij, loop back to show menu again
    done
}

# Run main if executed directly (not sourced)
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi

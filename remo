#!/bin/bash
# remo - Remote development environment CLI
# Manages Incus containers and Hetzner VMs for development environments

set -e

# Resolve symlinks to find the actual script location
SOURCE="${BASH_SOURCE[0]}"
while [ -h "$SOURCE" ]; do
    SCRIPT_DIR="$(cd -P "$(dirname "$SOURCE")" >/dev/null 2>&1 && pwd)"
    SOURCE="$(readlink "$SOURCE")"
    [[ $SOURCE != /* ]] && SOURCE="$SCRIPT_DIR/$SOURCE"
done
SCRIPT_DIR="$(cd -P "$(dirname "$SOURCE")" >/dev/null 2>&1 && pwd)"
ENV_FILE="$SCRIPT_DIR/.env"
ANSIBLE_DIR="$SCRIPT_DIR/ansible"
VENV_DIR="$SCRIPT_DIR/.venv"

# Config directory - follows XDG spec, can be overridden with REMO_HOME
REMO_HOME="${REMO_HOME:-${XDG_CONFIG_HOME:-$HOME/.config}/remo}"

# Activate virtual environment if it exists
if [ -d "$VENV_DIR" ] && [ -f "$VENV_DIR/bin/activate" ]; then
    source "$VENV_DIR/bin/activate"
fi

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Available tools for --only and --skip options
ALL_TOOLS="docker user_setup nodejs devcontainers github_cli fzf zellij"

# =============================================================================
# UTILITY FUNCTIONS
# =============================================================================

print_error() {
    echo -e "${RED}Error:${NC} $1" >&2
}

print_success() {
    echo -e "${GREEN}$1${NC}"
}

print_info() {
    echo -e "${BLUE}$1${NC}"
}

print_warning() {
    echo -e "${YELLOW}$1${NC}"
}

load_env() {
    if [ -f "$ENV_FILE" ]; then
        while IFS='=' read -r key value; do
            [[ -z "$key" || "$key" =~ ^[[:space:]]*# ]] && continue
            if [[ "$key" =~ ^[A-Za-z_][A-Za-z0-9_]*$ ]]; then
                export "$key=$value"
            fi
        done < "$ENV_FILE"
    fi
}

run_playbook() {
    local playbook="$1"
    shift
    cd "$ANSIBLE_DIR"
    ansible-playbook "$playbook" "$@"
}

# Build extra args for --only and --skip tool filtering
# Usage: build_tool_args only_array skip_array
# Sets TOOL_EXTRA_ARGS array as output
build_tool_args() {
    local -n only_ref=$1
    local -n skip_ref=$2
    TOOL_EXTRA_ARGS=()

    # Handle --only: disable all tools except specified ones
    if [ ${#only_ref[@]} -gt 0 ]; then
        for tool in $ALL_TOOLS; do
            local enabled="false"
            for o in "${only_ref[@]}"; do
                if [ "$tool" = "$o" ]; then
                    enabled="true"
                    break
                fi
            done
            TOOL_EXTRA_ARGS+=(-e "configure_${tool}=$enabled")
        done
    fi

    # Handle --skip: disable specified tools
    if [ ${#skip_ref[@]} -gt 0 ]; then
        for s in "${skip_ref[@]}"; do
            TOOL_EXTRA_ARGS+=(-e "configure_${s}=false")
        done
    fi
}

# =============================================================================
# HELP SYSTEM
# =============================================================================

show_main_help() {
    cat << 'EOF'
remo - Remote development environment CLI

USAGE:
    remo <command> [options]
    remo --help

COMMANDS:
    shell       Connect to a remo environment (auto-detects or picker)
    init        Initialize remo (install dependencies, create .env)
    incus       Manage Incus containers (local or remote host)
    hetzner     Manage Hetzner Cloud VMs
    aws         Manage AWS EC2 instances with EFS storage
    self-update Update remo to a newer version

ENVIRONMENT:
    REMO_HOME   Config directory (default: ~/.config/remo)

EXAMPLES:
    remo shell

    remo incus create dev1
    remo incus list
    remo incus update dev1 --only zellij
    remo incus destroy dev1 --yes
    remo incus bootstrap

    remo hetzner create
    remo hetzner list
    remo hetzner update
    remo hetzner destroy --yes

    remo aws create
    remo aws create --spot
    remo aws list
    remo aws update
    remo aws destroy --yes
    remo aws update-ip

    remo self-update
    remo self-update --pre-release

Run 'remo <command> --help' for command-specific options.
EOF
}

show_init_help() {
    cat << 'EOF'
remo init - Initialize remo environment

USAGE:
    remo init [options]

DESCRIPTION:
    Sets up remo by installing dependencies and creating configuration files.
    Run this once after cloning the repository.

    This command will:
    1. Create a Python virtual environment (.venv)
    2. Install Ansible and hcloud Python packages
    3. Install required Ansible collections
    4. Create .env from .env.example (if not exists)

OPTIONS:
    --force     Recreate venv even if it exists
    --help      Show this help message

EXAMPLES:
    remo init
    remo init --force
EOF
}

# =============================================================================
# INIT COMMAND
# =============================================================================

handle_init() {
    local force="false"

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --force)
                force="true"
                shift
                ;;
            --help|-h)
                show_init_help
                return 0
                ;;
            -*)
                print_error "Unknown option: $1"
                echo "Run 'remo init --help' for usage."
                exit 1
                ;;
            *)
                print_error "Unexpected argument: $1"
                exit 1
                ;;
        esac
    done

    echo ""
    print_info "Initializing remo..."
    echo ""

    # Step 1: Create virtual environment
    if [ -d "$VENV_DIR" ] && [ "$force" = "false" ]; then
        print_success "✓ Virtual environment already exists (.venv)"
    else
        if [ "$force" = "true" ] && [ -d "$VENV_DIR" ]; then
            print_info "Removing existing virtual environment..."
            rm -rf "$VENV_DIR"
        fi
        print_info "Creating virtual environment..."
        python3 -m venv "$VENV_DIR"
        print_success "✓ Created virtual environment (.venv)"
    fi

    # Use venv binaries directly
    local python="$VENV_DIR/bin/python"
    local ansible_galaxy="$VENV_DIR/bin/ansible-galaxy"

    # Step 2: Install Python packages
    # Use uv if available (faster), otherwise use pip
    print_info "Installing Python packages (ansible, hcloud, boto3)..."
    if command -v uv &> /dev/null; then
        uv pip install --quiet --python "$python" ansible hcloud boto3 botocore
    else
        # Ensure pip is available
        "$python" -m ensurepip --quiet 2>/dev/null || true
        "$python" -m pip install --quiet --upgrade pip
        "$python" -m pip install --quiet ansible hcloud boto3 botocore
    fi
    print_success "✓ Installed ansible, hcloud, and boto3"

    # Step 3: Install Ansible collections
    print_info "Installing Ansible collections..."
    "$ansible_galaxy" collection install -r "$ANSIBLE_DIR/requirements.yml" > /dev/null
    print_success "✓ Installed Ansible collections"

    # Step 4: Create .env file
    local env_example="$SCRIPT_DIR/.env.example"
    if [ -f "$ENV_FILE" ]; then
        print_success "✓ Configuration file already exists (.env)"
    elif [ -f "$env_example" ]; then
        cp "$env_example" "$ENV_FILE"
        print_success "✓ Created configuration file (.env)"
    else
        print_warning "⚠ No .env.example found, skipping .env creation"
    fi

    # Print next steps
    echo ""
    print_success "═══════════════════════════════════════════════════════════════"
    print_success "  remo initialized successfully!"
    print_success "═══════════════════════════════════════════════════════════════"
    echo ""

    if [ -f "$ENV_FILE" ]; then
        echo "Next step: Configure your credentials in .env"
        echo ""
        echo -e "  ${YELLOW}For Hetzner Cloud:${NC}"
        echo "    HETZNER_API_TOKEN  - Get from https://console.hetzner.cloud/"
        echo "    DUCKDNS_TOKEN      - Get from https://www.duckdns.org/"
        echo "    DUCKDNS_DOMAIN     - Your subdomain (without .duckdns.org)"
        echo ""
        echo -e "  ${YELLOW}For AWS:${NC}"
        echo "    AWS_ACCESS_KEY_ID      - Get from AWS IAM console"
        echo "    AWS_SECRET_ACCESS_KEY  - Get from AWS IAM console"
        echo "    AWS_REGION             - Optional (default: us-west-2)"
        echo ""
        echo -e "  ${YELLOW}For Incus (local/homelab):${NC}"
        echo "    No credentials needed - uses SSH keys"
        echo ""
        echo "Then run:"
        echo -e "  ${GREEN}./remo incus create dev1 --host <incus-host> --user <user>${NC}"
        echo -e "  ${GREEN}./remo hetzner create${NC}"
        echo -e "  ${GREEN}./remo aws create${NC}"
        echo ""
    fi
}

show_incus_help() {
    cat << 'EOF'
remo incus - Manage Incus containers

USAGE:
    remo incus <command> [options]

COMMANDS:
    create <name>       Create and configure a new container
    destroy <name>      Destroy an existing container
    update <name>       Update dev tools on an existing container
    list                List registered containers
    sync                Discover containers and update registry
    bootstrap           Initialize Incus host (network, storage)

CREATE OPTIONS:
    --domain <domain>   Set container domain (e.g., int.example.com)
    --image <image>     Container image (default: images:ubuntu/24.04/cloud)
    --host <host>       Remote Incus host (default: localhost)
    --user <user>       SSH user for remote host

DESTROY OPTIONS:
    --yes, -y           Skip confirmation prompt
    --host <host>       Remote Incus host (default: localhost)
    --user <user>       SSH user for remote host

UPDATE OPTIONS:
    --only <tool>       Only update specified tool (can repeat)
    --skip <tool>       Skip specified tool (can repeat)
    --host <host>       Remote Incus host (default: localhost)
    --user <user>       SSH user for remote host

    Available tools: docker, user_setup, nodejs, devcontainers, github_cli, fzf, zellij

BOOTSTRAP OPTIONS:
    --host <host>       Remote Incus host (default: localhost)
    --user <user>       SSH user for remote host
    -v, --verbose       Show detailed output

SYNC OPTIONS:
    --host <host>       Remote Incus host (default: localhost)
    --user <user>       SSH user for remote host

    Note: Sync replaces all entries for the specified host.

EXAMPLES:
    remo incus create dev1
    remo incus create dev1 --domain int.get2know.io
    remo incus create dev1 --host 192.168.1.100 --user admin
    remo incus list
    remo incus sync --host 192.168.1.100 --user admin
    remo incus update dev1 --only zellij
    remo incus update dev1 --skip docker --skip nodejs
    remo incus destroy dev1 --yes
    remo incus bootstrap --host myserver.local --user root
EOF
}

show_hetzner_help() {
    cat << 'EOF'
remo hetzner - Manage Hetzner Cloud VMs

USAGE:
    remo hetzner <command> [options]

COMMANDS:
    create              Provision a new Hetzner VM
    update              Update dev tools on an existing VM
    destroy             Tear down a Hetzner VM
    list                List registered Hetzner VMs
    sync                Discover VMs and update registry

CREATE OPTIONS:
    --name <name>       Server name (default: remote-coding-server)
    --type <type>       Server type (default: cx22)
    --location <loc>    Datacenter location (default: hel1)

UPDATE OPTIONS:
    --name <name>       Server name (default: remote-coding-server)
    --only <tool>       Only update specified tool (can repeat)
    --skip <tool>       Skip specified tool (can repeat)

    Available tools: docker, user_setup, nodejs, devcontainers, github_cli, fzf, zellij

DESTROY OPTIONS:
    --name <name>       Server name (default: remote-coding-server)
    --yes, -y           Skip confirmation prompt
    --remove-volume     Also remove the persistent volume (DESTROYS DATA!)

NOTES:
    Requires HETZNER_API_TOKEN in .env file or environment.
    The persistent volume is preserved by default on destroy.

EXAMPLES:
    remo hetzner create
    remo hetzner create --name my-server --type cx32
    remo hetzner sync
    remo hetzner update
    remo hetzner update --name my-server --only zellij
    remo hetzner destroy --yes
    remo hetzner destroy --name my-server --yes --remove-volume
EOF
}

# =============================================================================
# KNOWN HOSTS MANAGEMENT
# =============================================================================

KNOWN_HOSTS_FILE="$REMO_HOME/known_hosts"

# Ensure config directory exists
ensure_remo_dir() {
    mkdir -p "$REMO_HOME"
}

# Save a host entry
# Format: TYPE:NAME:HOST:USER
save_known_host() {
    local type="$1"   # aws, hetzner, incus
    local name="$2"   # instance/container name
    local host="$3"   # hostname or IP to connect to
    local user="$4"   # SSH user (usually remo)

    ensure_remo_dir
    touch "$KNOWN_HOSTS_FILE"

    local entry="${type}:${name}:${host}:${user}"

    # Remove existing entry for this type:name, then add new one
    grep -v "^${type}:${name}:" "$KNOWN_HOSTS_FILE" > "${KNOWN_HOSTS_FILE}.tmp" 2>/dev/null || true
    mv "${KNOWN_HOSTS_FILE}.tmp" "$KNOWN_HOSTS_FILE"
    echo "$entry" >> "$KNOWN_HOSTS_FILE"
}

# Remove a host entry
remove_known_host() {
    local type="$1"
    local name="$2"

    [ ! -f "$KNOWN_HOSTS_FILE" ] && return 0

    grep -v "^${type}:${name}:" "$KNOWN_HOSTS_FILE" > "${KNOWN_HOSTS_FILE}.tmp" 2>/dev/null || true
    mv "${KNOWN_HOSTS_FILE}.tmp" "$KNOWN_HOSTS_FILE"
}

# Clear all entries for a given type
clear_known_hosts_by_type() {
    local type="$1"

    [ ! -f "$KNOWN_HOSTS_FILE" ] && return 0

    grep -v "^${type}:" "$KNOWN_HOSTS_FILE" > "${KNOWN_HOSTS_FILE}.tmp" 2>/dev/null || true
    mv "${KNOWN_HOSTS_FILE}.tmp" "$KNOWN_HOSTS_FILE"
}

# Clear all entries for a given type and name prefix (e.g., incus:myhost/*)
clear_known_hosts_by_prefix() {
    local type="$1"
    local prefix="$2"

    [ ! -f "$KNOWN_HOSTS_FILE" ] && return 0

    grep -v "^${type}:${prefix}" "$KNOWN_HOSTS_FILE" > "${KNOWN_HOSTS_FILE}.tmp" 2>/dev/null || true
    mv "${KNOWN_HOSTS_FILE}.tmp" "$KNOWN_HOSTS_FILE"
}

# Get all known hosts (optionally filtered by type)
get_known_hosts() {
    local filter_type="${1:-}"

    [ ! -f "$KNOWN_HOSTS_FILE" ] && return 0

    if [ -n "$filter_type" ]; then
        grep "^${filter_type}:" "$KNOWN_HOSTS_FILE" 2>/dev/null || true
    else
        cat "$KNOWN_HOSTS_FILE" 2>/dev/null || true
    fi
}

# =============================================================================
# INCUS COMMANDS
# =============================================================================

incus_create() {
    local name=""
    local domain=""
    local image=""
    local host="localhost"
    local user=""
    local extra_args=()

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --domain)
                domain="$2"
                shift 2
                ;;
            --image)
                image="$2"
                shift 2
                ;;
            --host)
                host="$2"
                shift 2
                ;;
            --user)
                user="$2"
                shift 2
                ;;
            -*)
                print_error "Unknown option: $1"
                echo "Run 'remo incus --help' for usage."
                exit 1
                ;;
            *)
                if [ -z "$name" ]; then
                    name="$1"
                else
                    print_error "Unexpected argument: $1"
                    exit 1
                fi
                shift
                ;;
        esac
    done

    if [ -z "$name" ]; then
        print_error "Container name is required"
        echo "Usage: remo incus create <name> [options]"
        exit 1
    fi

    print_info "Creating Incus container '$name'..."

    # Build ansible extra vars
    extra_args+=(-e "container_name=$name")

    [ -n "$domain" ] && extra_args+=(-e "container_domain=$domain")
    [ -n "$image" ] && extra_args+=(-e "container_image=$image")

    if [ "$host" != "localhost" ]; then
        extra_args+=(-i "$host,")
        extra_args+=(-e "target_hosts=all")
        [ -n "$user" ] && extra_args+=(-e "incus_host_user=$user")
    fi

    run_playbook incus_site.yml "${extra_args[@]}"

    # Save to known_hosts on success
    # Format: incus:HOST/CONTAINER:CONTAINER:remo
    save_known_host "incus" "${host}/${name}" "$name" "remo"
}

incus_destroy() {
    local name=""
    local auto_confirm="false"
    local host="localhost"
    local user=""
    local extra_args=()

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --yes|-y)
                auto_confirm="true"
                shift
                ;;
            --host)
                host="$2"
                shift 2
                ;;
            --user)
                user="$2"
                shift 2
                ;;
            -*)
                print_error "Unknown option: $1"
                echo "Run 'remo incus --help' for usage."
                exit 1
                ;;
            *)
                if [ -z "$name" ]; then
                    name="$1"
                else
                    print_error "Unexpected argument: $1"
                    exit 1
                fi
                shift
                ;;
        esac
    done

    if [ -z "$name" ]; then
        print_error "Container name is required"
        echo "Usage: remo incus destroy <name> [options]"
        exit 1
    fi

    print_info "Destroying Incus container '$name'..."

    extra_args+=(-e "container_name=$name")
    extra_args+=(-e "auto_confirm=$auto_confirm")

    if [ "$host" != "localhost" ]; then
        extra_args+=(-i "$host,")
        extra_args+=(-e "target_hosts=all")
        [ -n "$user" ] && extra_args+=(-e "incus_host_user=$user")
    fi

    run_playbook incus_teardown.yml "${extra_args[@]}"

    # Remove from known_hosts
    # Format: incus:HOST/CONTAINER:CONTAINER:remo
    remove_known_host "incus" "${host}/${name}"
}

incus_list() {
    echo ""
    printf "%-20s %-20s %-20s %s\n" "CONTAINER" "INCUS HOST" "SSH HOST" "SSH COMMAND"
    printf "%-20s %-20s %-20s %s\n" "---------" "----------" "--------" "-----------"

    while IFS=: read -r type name host user; do
        [ "$type" != "incus" ] && continue
        # name is in format: incus_host/container_name
        local incus_host="${name%/*}"
        local container="${name#*/}"
        printf "%-20s %-20s %-20s %s\n" "$container" "$incus_host" "$host" "ssh ${user}@${host}"
    done < <(get_known_hosts "incus")

    local count
    count=$(get_known_hosts "incus" | wc -l)
    if [ "$count" -eq 0 ]; then
        echo "No Incus containers registered."
        echo ""
        echo "Create one with: remo incus create <name>"
    fi
}

incus_sync() {
    local host="localhost"
    local user=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --host)
                host="$2"
                shift 2
                ;;
            --user)
                user="$2"
                shift 2
                ;;
            -*)
                print_error "Unknown option: $1"
                echo "Run 'remo incus --help' for usage."
                exit 1
                ;;
            *)
                print_error "Unexpected argument: $1"
                exit 1
                ;;
        esac
    done

    print_info "Discovering Incus containers on '$host'..."

    local containers
    local ssh_target="$host"
    [ -n "$user" ] && ssh_target="${user}@${host}"

    if [ "$host" = "localhost" ]; then
        if ! command -v incus &> /dev/null; then
            print_error "incus command not found on localhost"
            return 1
        fi
        containers=$(incus list -f csv -c n 2>&1)
    else
        # Test SSH connection first
        if ! ssh -o BatchMode=yes -o ConnectTimeout=5 "$ssh_target" "true" 2>/dev/null; then
            print_error "Cannot connect to '$ssh_target'. Check SSH access or specify --user."
            return 1
        fi
        containers=$(ssh "$ssh_target" "incus list -f csv -c n" 2>&1)
        if [ $? -ne 0 ]; then
            print_error "Failed to run incus on '$host': $containers"
            return 1
        fi
    fi

    # Clear existing entries for this host and replace with discovered ones
    clear_known_hosts_by_prefix "incus" "${host}/"

    if [ -z "$containers" ]; then
        print_warning "No Incus containers found on '$host'."
        return 0
    fi

    local count=0
    while IFS= read -r name; do
        [ -z "$name" ] && continue
        # Format: incus:HOST/CONTAINER:CONTAINER:remo
        save_known_host "incus" "${host}/${name}" "$name" "remo"
        print_success "  Registered: $name"
        ((count++)) || true
    done <<< "$containers"

    echo ""
    print_success "Synced $count Incus container(s) to known_hosts."
}

incus_bootstrap() {
    local host="localhost"
    local user=""
    local verbose=""
    local extra_args=()

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --host)
                host="$2"
                shift 2
                ;;
            --user)
                user="$2"
                shift 2
                ;;
            -v|--verbose)
                verbose="detailed"
                shift
                ;;
            -*)
                print_error "Unknown option: $1"
                echo "Run 'remo incus --help' for usage."
                exit 1
                ;;
            *)
                print_error "Unexpected argument: $1"
                exit 1
                ;;
        esac
    done

    print_info "Bootstrapping Incus host..."

    if [ "$host" != "localhost" ]; then
        extra_args+=(-i "$host,")
        extra_args+=(-e "target_hosts=all")
        [ -n "$user" ] && extra_args+=(-e "ansible_user=$user")
    fi

    [ -n "$verbose" ] && extra_args+=(-e "incus_bootstrap_verbosity=$verbose")

    run_playbook incus_bootstrap.yml "${extra_args[@]}"
}

incus_update() {
    local name=""
    local host="localhost"
    local user=""
    local only=()
    local skip=()
    local extra_args=()

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --host)
                host="$2"
                shift 2
                ;;
            --user)
                user="$2"
                shift 2
                ;;
            --only)
                only+=("$2")
                shift 2
                ;;
            --skip)
                skip+=("$2")
                shift 2
                ;;
            -*)
                print_error "Unknown option: $1"
                echo "Run 'remo incus --help' for usage."
                exit 1
                ;;
            *)
                if [ -z "$name" ]; then
                    name="$1"
                else
                    print_error "Unexpected argument: $1"
                    exit 1
                fi
                shift
                ;;
        esac
    done

    if [ -z "$name" ]; then
        print_error "Container name is required"
        echo "Usage: remo incus update <name> [options]"
        exit 1
    fi

    # Get container IP from Incus host
    print_info "Looking up container '$name'..."
    local container_ip
    if [ "$host" = "localhost" ]; then
        container_ip=$(incus list "$name" -f csv -c 4 2>/dev/null | grep -oE '([0-9]{1,3}\.){3}[0-9]{1,3}' | head -1)
    else
        local ssh_target="$host"
        [ -n "$user" ] && ssh_target="${user}@${host}"
        container_ip=$(ssh "$ssh_target" "incus list '$name' -f csv -c 4" 2>/dev/null | grep -oE '([0-9]{1,3}\.){3}[0-9]{1,3}' | head -1)
    fi

    if [ -z "$container_ip" ]; then
        print_error "Could not find IP for container '$name'"
        exit 1
    fi

    print_info "Found container at $container_ip"
    print_info "Configuring container '$name'..."

    extra_args+=(-e "container_ip=$container_ip")

    build_tool_args only skip
    extra_args+=("${TOOL_EXTRA_ARGS[@]}")

    run_playbook incus_configure.yml "${extra_args[@]}"
}

handle_incus() {
    local command="${1:-}"
    shift || true

    case "$command" in
        create)
            incus_create "$@"
            ;;
        destroy)
            incus_destroy "$@"
            ;;
        update)
            incus_update "$@"
            ;;
        list)
            incus_list "$@"
            ;;
        sync)
            incus_sync "$@"
            ;;
        bootstrap)
            incus_bootstrap "$@"
            ;;
        --help|-h|"")
            show_incus_help
            ;;
        *)
            print_error "Unknown incus command: $command"
            echo "Run 'remo incus --help' for available commands."
            exit 1
            ;;
    esac
}

# =============================================================================
# SELF-UPDATE COMMAND
# =============================================================================

show_self_update_help() {
    cat << 'EOF'
remo self-update - Update remo to a newer version

USAGE:
    remo self-update [options]

OPTIONS:
    --version <version>   Update to specific version (e.g., v1.0.0)
    --pre-release         Update to latest pre-release version
    --check               Check for updates without installing
    --help                Show this help message

EXAMPLES:
    remo self-update                    # Update to latest stable
    remo self-update --pre-release      # Update to latest pre-release
    remo self-update --version v1.0.0   # Update to specific version
    remo self-update --check            # Check for available updates
EOF
}

get_latest_release() {
    local include_prerelease="$1"
    local releases

    releases=$(curl -fsSL "https://api.github.com/repos/get2knowio/remo/releases?per_page=20" 2>/dev/null)

    if [ "$include_prerelease" = "true" ]; then
        echo "$releases" | grep -o '"tag_name": "[^"]*"' | head -1 | cut -d'"' -f4
    else
        echo "$releases" | python3 -c "
import sys, json
releases = json.load(sys.stdin)
for r in releases:
    if not r.get('prerelease', False) and not r.get('draft', False):
        tag = r.get('tag_name', '')
        if '-rc' not in tag and '-beta' not in tag and '-alpha' not in tag:
            print(tag)
            break
" 2>/dev/null || echo ""
    fi
}

handle_self_update() {
    local version=""
    local pre_release="false"
    local check_only="false"

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --version)
                version="$2"
                shift 2
                ;;
            --pre-release)
                pre_release="true"
                shift
                ;;
            --check)
                check_only="true"
                shift
                ;;
            --help|-h)
                show_self_update_help
                return 0
                ;;
            -*)
                print_error "Unknown option: $1"
                echo "Run 'remo self-update --help' for usage."
                exit 1
                ;;
            *)
                print_error "Unexpected argument: $1"
                exit 1
                ;;
        esac
    done

    # Get current version
    local current_version=""
    if [ -f "$SCRIPT_DIR/VERSION" ]; then
        current_version=$(cat "$SCRIPT_DIR/VERSION")
    fi

    print_info "Current version: ${current_version:-unknown}"

    # Determine target version
    local target_version=""
    if [ -n "$version" ]; then
        target_version="$version"
    elif [ "$pre_release" = "true" ]; then
        print_info "Checking for latest pre-release..."
        target_version=$(get_latest_release true)
    else
        print_info "Checking for latest stable release..."
        target_version=$(get_latest_release false)
    fi

    if [ -z "$target_version" ]; then
        print_error "Could not determine target version"
        exit 1
    fi

    # Strip 'v' prefix for comparison
    local target_clean="${target_version#v}"
    local current_clean="${current_version#v}"

    print_info "Latest version: $target_version"

    if [ "$target_clean" = "$current_clean" ]; then
        print_success "Already up to date!"
        return 0
    fi

    if [ "$check_only" = "true" ]; then
        echo ""
        print_warning "Update available: $current_version -> $target_version"
        echo "Run 'remo self-update' to install"
        return 0
    fi

    echo ""
    print_info "Updating remo: $current_version -> $target_version"
    echo ""

    # Fetch and checkout the new version
    cd "$SCRIPT_DIR"

    print_info "Fetching updates..."
    git fetch --tags origin 2>/dev/null

    print_info "Checking out $target_version..."
    git checkout "$target_version" 2>/dev/null

    # Re-run init to update dependencies
    print_info "Updating dependencies..."
    ./remo init

    echo ""
    print_success "=============================================="
    print_success "  remo updated to $target_version"
    print_success "=============================================="
    echo ""
}

# =============================================================================
# HETZNER COMMANDS
# =============================================================================

hetzner_create() {
    local name=""
    local server_type=""
    local location=""
    local extra_args=()

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --name)
                name="$2"
                shift 2
                ;;
            --type)
                server_type="$2"
                shift 2
                ;;
            --location)
                location="$2"
                shift 2
                ;;
            -*)
                print_error "Unknown option: $1"
                echo "Run 'remo hetzner --help' for usage."
                exit 1
                ;;
            *)
                print_error "Unexpected argument: $1"
                exit 1
                ;;
        esac
    done

    print_info "Creating Hetzner VM..."

    [ -n "$name" ] && extra_args+=(-e "hetzner_server_name=$name")
    [ -n "$server_type" ] && extra_args+=(-e "hetzner_server_type=$server_type")
    [ -n "$location" ] && extra_args+=(-e "hetzner_location=$location")

    run_playbook hetzner_site.yml "${extra_args[@]}"

    # Save to known_hosts on success
    local server_name="${name:-remote-coding-server}"
    local domain="${DUCKDNS_DOMAIN:-}"
    if [ -n "$domain" ]; then
        save_known_host "hetzner" "$server_name" "${domain}.duckdns.org" "remo"
    fi
}

hetzner_destroy() {
    local name=""
    local auto_confirm="false"
    local remove_volume="false"
    local extra_args=()

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --name)
                name="$2"
                shift 2
                ;;
            --yes|-y)
                auto_confirm="true"
                shift
                ;;
            --remove-volume)
                remove_volume="true"
                shift
                ;;
            -*)
                print_error "Unknown option: $1"
                echo "Run 'remo hetzner --help' for usage."
                exit 1
                ;;
            *)
                print_error "Unexpected argument: $1"
                exit 1
                ;;
        esac
    done

    local server_name="${name:-remote-coding-server}"

    if [ "$remove_volume" = "true" ]; then
        print_warning "WARNING: --remove-volume will destroy all data on the persistent volume!"
    fi

    print_info "Destroying Hetzner VM '$server_name'..."

    [ -n "$name" ] && extra_args+=(-e "hetzner_server_name=$name")
    extra_args+=(-e "auto_confirm=$auto_confirm")
    extra_args+=(-e "remove_volume=$remove_volume")

    run_playbook hetzner_teardown.yml "${extra_args[@]}"

    # Remove from known_hosts
    remove_known_host "hetzner" "$server_name"
}

hetzner_update() {
    local name=""
    local only=()
    local skip=()
    local extra_args=()

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --name)
                name="$2"
                shift 2
                ;;
            --only)
                only+=("$2")
                shift 2
                ;;
            --skip)
                skip+=("$2")
                shift 2
                ;;
            -*)
                print_error "Unknown option: $1"
                echo "Run 'remo hetzner --help' for usage."
                exit 1
                ;;
            *)
                print_error "Unexpected argument: $1"
                exit 1
                ;;
        esac
    done

    local server_name="${name:-remote-coding-server}"

    # Get server IP from DuckDNS domain
    local domain="${DUCKDNS_DOMAIN:-}"
    if [ -z "$domain" ]; then
        print_error "DUCKDNS_DOMAIN not set. Cannot determine server address."
        exit 1
    fi

    local server_host="${domain}.duckdns.org"
    print_info "Updating Hetzner VM '$server_name' at $server_host..."

    build_tool_args only skip
    extra_args+=("${TOOL_EXTRA_ARGS[@]}")

    run_playbook hetzner_configure.yml -i "${server_host}," -e "ansible_user=remo" "${extra_args[@]}"
}

hetzner_list() {
    echo ""
    printf "%-25s %-25s %s\n" "NAME" "HOST" "SSH COMMAND"
    printf "%-25s %-25s %s\n" "----" "----" "-----------"

    while IFS=: read -r type name host user; do
        [ "$type" != "hetzner" ] && continue
        printf "%-25s %-25s %s\n" "$name" "$host" "ssh ${user}@${host}"
    done < <(get_known_hosts "hetzner")

    local count
    count=$(get_known_hosts "hetzner" | wc -l)
    if [ "$count" -eq 0 ]; then
        echo "No Hetzner VMs registered."
        echo ""
        echo "Create one with: remo hetzner create"
    fi
}

hetzner_sync() {
    print_info "Discovering Hetzner VMs..."

    local token="${HETZNER_API_TOKEN:-}"
    if [ -z "$token" ]; then
        print_error "HETZNER_API_TOKEN not set. Cannot query Hetzner API."
        exit 1
    fi

    local domain="${DUCKDNS_DOMAIN:-}"
    if [ -z "$domain" ]; then
        print_error "DUCKDNS_DOMAIN not set. Cannot determine server addresses."
        exit 1
    fi

    # Query Hetzner API for servers with remo label
    local servers
    servers=$(curl -fsSL -H "Authorization: Bearer $token" \
        "https://api.hetzner.cloud/v1/servers?label_selector=remo" 2>/dev/null || true)

    if [ -z "$servers" ]; then
        print_warning "Could not query Hetzner API."
        return 1
    fi

    # Clear existing Hetzner entries and replace with discovered ones
    clear_known_hosts_by_type "hetzner"

    local count=0
    while IFS= read -r name; do
        [ -z "$name" ] && continue
        local host="${domain}.duckdns.org"
        save_known_host "hetzner" "$name" "$host" "remo"
        print_success "  Registered: $name -> $host"
        ((count++)) || true
    done < <(echo "$servers" | python3 -c "
import sys, json
data = json.load(sys.stdin)
for server in data.get('servers', []):
    print(server.get('name', ''))
" 2>/dev/null || true)

    if [ "$count" -eq 0 ]; then
        print_warning "No Hetzner VMs found with 'remo' label."
    else
        echo ""
        print_success "Synced $count Hetzner VM(s) to known_hosts."
    fi
}

handle_hetzner() {
    local command="${1:-}"
    shift || true

    case "$command" in
        create)
            hetzner_create "$@"
            ;;
        update)
            hetzner_update "$@"
            ;;
        destroy)
            hetzner_destroy "$@"
            ;;
        list)
            hetzner_list "$@"
            ;;
        sync)
            hetzner_sync "$@"
            ;;
        --help|-h|"")
            show_hetzner_help
            ;;
        *)
            print_error "Unknown hetzner command: $command"
            echo "Run 'remo hetzner --help' for available commands."
            exit 1
            ;;
    esac
}

# =============================================================================
# AWS COMMANDS
# =============================================================================

show_aws_help() {
    cat << 'EOF'
remo aws - Manage AWS EC2 instances with EFS storage

USAGE:
    remo aws <command> [options]

COMMANDS:
    create              Provision a new AWS EC2 instance
    update              Update dev tools on an existing instance
    destroy             Tear down an AWS EC2 instance
    update-ip           Update security group with current IP
    info                Show instance information
    list                List registered AWS instances
    sync                Discover instances and update registry

CREATE OPTIONS:
    --name <name>       Resource namespace (default: $USER)
    --type <type>       Instance type (default: t3.medium)
    --region <region>   AWS region (default: us-west-2)
    --spot              Use spot instance (cheaper but can be interrupted)
    --dns               Also create Route53 DNS record

UPDATE OPTIONS:
    --only <tool>       Only update specified tool (can repeat)
    --skip <tool>       Skip specified tool (can repeat)
    --name <name>       Resource namespace (default: $USER)

    Available tools: docker, user_setup, nodejs, devcontainers, github_cli, fzf, zellij

DESTROY OPTIONS:
    --yes, -y           Skip confirmation prompt
    --remove-efs        Also remove the EFS filesystem (DESTROYS DATA!)
    --name <name>       Resource namespace (default: $USER)

UPDATE-IP OPTIONS:
    --name <name>       Resource namespace (default: $USER)

NOTES:
    Requires AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY in .env file.
    The EFS filesystem is preserved by default on destroy.
    Resources are namespaced by --name to support multiple users.

SSH ACCESS:
    After provisioning, connect using:
        ssh remo-aws

    SSH config is automatically updated in ~/.ssh/config

EXAMPLES:
    remo aws create
    remo aws create --spot
    remo aws create --name alice --type t3.large
    remo aws create --dns
    remo aws sync
    remo aws update
    remo aws update --only zellij
    remo aws destroy --yes
    remo aws destroy --yes --remove-efs
    remo aws update-ip
    remo aws info
EOF
}

aws_create() {
    local name=""
    local instance_type=""
    local region=""
    local use_spot="false"
    local create_dns="false"
    local extra_args=()

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --name)
                name="$2"
                shift 2
                ;;
            --type)
                instance_type="$2"
                shift 2
                ;;
            --region)
                region="$2"
                shift 2
                ;;
            --spot)
                use_spot="true"
                shift
                ;;
            --dns)
                create_dns="true"
                shift
                ;;
            -*)
                print_error "Unknown option: $1"
                echo "Run 'remo aws --help' for usage."
                exit 1
                ;;
            *)
                print_error "Unexpected argument: $1"
                exit 1
                ;;
        esac
    done

    print_info "Creating AWS EC2 instance..."

    local resource_name="${name:-$USER}"

    [ -n "$name" ] && extra_args+=(-e "aws_resource_name=$name")
    [ -n "$instance_type" ] && extra_args+=(-e "aws_instance_type=$instance_type")
    [ -n "$region" ] && extra_args+=(-e "aws_region=$region")
    [ "$use_spot" = "true" ] && extra_args+=(-e "aws_use_spot=true")
    [ "$create_dns" = "true" ] && extra_args+=(-e "aws_create_dns=true")

    run_playbook aws_site.yml "${extra_args[@]}"

    # Save to known_hosts on success - get the instance IP
    local instance_ip
    instance_ip=$(python3 << EOF
import os
import sys

try:
    import boto3
except ImportError:
    sys.exit(0)

region = os.environ.get('AWS_REGION', '${region:-us-west-2}')
access_key = os.environ.get('AWS_ACCESS_KEY_ID', '')
secret_key = os.environ.get('AWS_SECRET_ACCESS_KEY', '')

if not access_key or not secret_key:
    sys.exit(0)

try:
    ec2 = boto3.client('ec2', region_name=region, aws_access_key_id=access_key, aws_secret_access_key=secret_key)
    response = ec2.describe_instances(
        Filters=[
            {'Name': 'tag:Name', 'Values': ['remo-${resource_name}']},
            {'Name': 'tag:remo', 'Values': ['true']},
            {'Name': 'instance-state-name', 'Values': ['running']}
        ]
    )
    for reservation in response.get('Reservations', []):
        for instance in reservation.get('Instances', []):
            ip = instance.get('PublicIpAddress', '')
            if ip:
                print(ip)
                break
except Exception:
    pass
EOF
)
    if [ -n "$instance_ip" ]; then
        save_known_host "aws" "$resource_name" "$instance_ip" "remo"
    fi
}

aws_destroy() {
    local auto_confirm="false"
    local remove_efs="false"
    local name=""
    local extra_args=()

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --yes|-y)
                auto_confirm="true"
                shift
                ;;
            --remove-efs)
                remove_efs="true"
                shift
                ;;
            --name)
                name="$2"
                shift 2
                ;;
            -*)
                print_error "Unknown option: $1"
                echo "Run 'remo aws --help' for usage."
                exit 1
                ;;
            *)
                print_error "Unexpected argument: $1"
                exit 1
                ;;
        esac
    done

    if [ "$remove_efs" = "true" ]; then
        print_warning "WARNING: --remove-efs will destroy all data on the EFS filesystem!"
    fi

    print_info "Destroying AWS EC2 instance..."

    local resource_name="${name:-$USER}"

    [ -n "$name" ] && extra_args+=(-e "aws_resource_name=$name")
    extra_args+=(-e "auto_confirm=$auto_confirm")
    extra_args+=(-e "remove_efs=$remove_efs")

    run_playbook aws_teardown.yml "${extra_args[@]}"

    # Remove from known_hosts
    remove_known_host "aws" "$resource_name"
}

aws_update_ip() {
    local name=""
    local extra_args=()

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --name)
                name="$2"
                shift 2
                ;;
            -*)
                print_error "Unknown option: $1"
                echo "Run 'remo aws --help' for usage."
                exit 1
                ;;
            *)
                print_error "Unexpected argument: $1"
                exit 1
                ;;
        esac
    done

    print_info "Updating AWS security group with current IP..."

    [ -n "$name" ] && extra_args+=(-e "aws_resource_name=$name")

    run_playbook aws_update_ip.yml "${extra_args[@]}"
}

aws_info() {
    local name=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --name)
                name="$2"
                shift 2
                ;;
            -*)
                print_error "Unknown option: $1"
                echo "Run 'remo aws --help' for usage."
                exit 1
                ;;
            *)
                print_error "Unexpected argument: $1"
                exit 1
                ;;
        esac
    done

    # Use Python with boto3 to get instance info
    local resource_name="${name:-$USER}"

    python3 << EOF
import os
import sys

try:
    import boto3
except ImportError:
    print("Error: boto3 is not installed. Run 'remo init' first.", file=sys.stderr)
    sys.exit(1)

region = os.environ.get('AWS_REGION', 'us-west-2')
access_key = os.environ.get('AWS_ACCESS_KEY_ID', '')
secret_key = os.environ.get('AWS_SECRET_ACCESS_KEY', '')

if not access_key or not secret_key:
    print("Error: AWS credentials not set. Configure AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY.", file=sys.stderr)
    sys.exit(1)

ec2 = boto3.client('ec2', region_name=region, aws_access_key_id=access_key, aws_secret_access_key=secret_key)

instance_name = "remo-${resource_name}"

response = ec2.describe_instances(
    Filters=[
        {'Name': 'tag:Name', 'Values': [instance_name]},
        {'Name': 'tag:remo', 'Values': ['true']},
        {'Name': 'instance-state-name', 'Values': ['pending', 'running', 'stopping', 'stopped']}
    ]
)

instances = []
for reservation in response.get('Reservations', []):
    instances.extend(reservation.get('Instances', []))

if not instances:
    print(f"No AWS instance found with name: {instance_name}")
    print(f"Run 'remo aws create' to provision a new instance.")
    sys.exit(0)

instance = instances[0]
state = instance.get('State', {}).get('Name', 'unknown')
instance_id = instance.get('InstanceId', 'unknown')
instance_type = instance.get('InstanceType', 'unknown')
public_ip = instance.get('PublicIpAddress', 'N/A')
public_dns = instance.get('PublicDnsName', 'N/A')
launch_time = instance.get('LaunchTime', 'unknown')

print(f"""
AWS Instance Information:
========================
Name:          {instance_name}
Instance ID:   {instance_id}
State:         {state}
Type:          {instance_type}
Region:        {region}
Public IP:     {public_ip}
Public DNS:    {public_dns}
Launch Time:   {launch_time}

SSH Connection:
  ssh remo-aws
  ssh remo@{public_ip}
""")
EOF
}

aws_update() {
    local name=""
    local only=()
    local skip=()
    local extra_args=()

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --name)
                name="$2"
                shift 2
                ;;
            --only)
                only+=("$2")
                shift 2
                ;;
            --skip)
                skip+=("$2")
                shift 2
                ;;
            -*)
                print_error "Unknown option: $1"
                echo "Run 'remo aws --help' for usage."
                exit 1
                ;;
            *)
                print_error "Unexpected argument: $1"
                exit 1
                ;;
        esac
    done

    # Get instance IP using aws_info logic
    local resource_name="${name:-$USER}"
    local instance_ip

    instance_ip=$(python3 << EOF
import os
import sys

try:
    import boto3
except ImportError:
    sys.exit(1)

region = os.environ.get('AWS_REGION', 'us-west-2')
access_key = os.environ.get('AWS_ACCESS_KEY_ID', '')
secret_key = os.environ.get('AWS_SECRET_ACCESS_KEY', '')

if not access_key or not secret_key:
    sys.exit(1)

ec2 = boto3.client('ec2', region_name=region, aws_access_key_id=access_key, aws_secret_access_key=secret_key)

response = ec2.describe_instances(
    Filters=[
        {'Name': 'tag:Name', 'Values': ['remo-${resource_name}']},
        {'Name': 'tag:remo', 'Values': ['true']},
        {'Name': 'instance-state-name', 'Values': ['running']}
    ]
)

instances = []
for reservation in response.get('Reservations', []):
    instances.extend(reservation.get('Instances', []))

if instances:
    print(instances[0].get('PublicIpAddress', ''))
EOF
)

    if [ -z "$instance_ip" ]; then
        print_error "Could not find running AWS instance for '$resource_name'"
        echo "Run 'remo aws info --name $resource_name' to check instance status."
        exit 1
    fi

    print_info "Updating AWS instance at $instance_ip..."

    # Update known_hosts with current IP (may have changed, especially for spot instances)
    save_known_host "aws" "$resource_name" "$instance_ip" "remo"

    build_tool_args only skip
    extra_args+=("${TOOL_EXTRA_ARGS[@]}")

    run_playbook aws_configure.yml -e "instance_ip=$instance_ip" "${extra_args[@]}"
}

aws_list() {
    echo ""
    printf "%-25s %-25s %s\n" "NAME" "HOST" "SSH COMMAND"
    printf "%-25s %-25s %s\n" "----" "----" "-----------"

    while IFS=: read -r type name host user; do
        [ "$type" != "aws" ] && continue
        printf "%-25s %-25s %s\n" "$name" "$host" "ssh ${user}@${host}"
    done < <(get_known_hosts "aws")

    local count
    count=$(get_known_hosts "aws" | wc -l)
    if [ "$count" -eq 0 ]; then
        echo "No AWS instances registered."
        echo ""
        echo "Create one with: remo aws create"
    fi
}

aws_sync() {
    print_info "Discovering AWS instances..."

    local region="${AWS_REGION:-us-west-2}"
    local access_key="${AWS_ACCESS_KEY_ID:-}"
    local secret_key="${AWS_SECRET_ACCESS_KEY:-}"

    if [ -z "$access_key" ] || [ -z "$secret_key" ]; then
        print_error "AWS credentials not set. Configure AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY."
        exit 1
    fi

    # Query AWS for remo instances
    local result
    result=$(python3 << EOF
import os
import sys
import json

try:
    import boto3
except ImportError:
    print('{"error": "boto3 not installed"}')
    sys.exit(0)

region = "${region}"
access_key = os.environ.get('AWS_ACCESS_KEY_ID', '${access_key}')
secret_key = os.environ.get('AWS_SECRET_ACCESS_KEY', '${secret_key}')

try:
    ec2 = boto3.client('ec2', region_name=region, aws_access_key_id=access_key, aws_secret_access_key=secret_key)
    response = ec2.describe_instances(
        Filters=[
            {'Name': 'tag:remo', 'Values': ['true']},
            {'Name': 'instance-state-name', 'Values': ['running']}
        ]
    )

    instances = []
    for reservation in response.get('Reservations', []):
        for instance in reservation.get('Instances', []):
            name = ''
            for tag in instance.get('Tags', []):
                if tag['Key'] == 'Name':
                    name = tag['Value']
                    break
            ip = instance.get('PublicIpAddress', '')
            if name and ip:
                # Strip 'remo-' prefix if present for the resource name
                resource_name = name[5:] if name.startswith('remo-') else name
                instances.append({'name': resource_name, 'ip': ip})

    print(json.dumps({'instances': instances}))
except Exception as e:
    print(json.dumps({'error': str(e)}))
EOF
)

    if echo "$result" | grep -q '"error"'; then
        local error
        error=$(echo "$result" | python3 -c "import sys,json; print(json.load(sys.stdin).get('error','Unknown error'))" 2>/dev/null)
        print_error "Failed to query AWS: $error"
        return 1
    fi

    # Clear existing AWS entries and replace with discovered ones
    clear_known_hosts_by_type "aws"

    local count=0
    while IFS= read -r line; do
        [ -z "$line" ] && continue
        local name ip
        name=$(echo "$line" | cut -d'|' -f1)
        ip=$(echo "$line" | cut -d'|' -f2)
        [ -z "$name" ] || [ -z "$ip" ] && continue
        save_known_host "aws" "$name" "$ip" "remo"
        print_success "  Registered: $name -> $ip"
        ((count++)) || true
    done < <(echo "$result" | python3 -c "
import sys, json
data = json.load(sys.stdin)
for inst in data.get('instances', []):
    print(f\"{inst['name']}|{inst['ip']}\")
" 2>/dev/null || true)

    if [ "$count" -eq 0 ]; then
        print_warning "No running AWS instances found with 'remo' tag."
    else
        echo ""
        print_success "Synced $count AWS instance(s) to known_hosts."
    fi
}

handle_aws() {
    local command="${1:-}"
    shift || true

    case "$command" in
        create)
            aws_create "$@"
            ;;
        update)
            aws_update "$@"
            ;;
        destroy)
            aws_destroy "$@"
            ;;
        update-ip)
            aws_update_ip "$@"
            ;;
        info)
            aws_info "$@"
            ;;
        list)
            aws_list "$@"
            ;;
        sync)
            aws_sync "$@"
            ;;
        --help|-h|"")
            show_aws_help
            ;;
        *)
            print_error "Unknown aws command: $command"
            echo "Run 'remo aws --help' for available commands."
            exit 1
            ;;
    esac
}

# =============================================================================
# SHELL COMMAND
# =============================================================================

show_shell_help() {
    cat << 'EOF'
remo shell - Connect to a remo environment

USAGE:
    remo shell

DESCRIPTION:
    Connects to a registered remo environment:
    - If exactly one environment exists, connects directly
    - If multiple environments exist, shows an interactive picker

    Environments are registered when created with remo <platform> create.
    Use 'remo <platform> list' to see registered environments.

EXAMPLES:
    remo shell              # Connect (or pick if multiple)
    remo aws list           # List AWS instances
    remo hetzner list       # List Hetzner VMs
    remo incus list         # List Incus containers
EOF
}

shell_connect() {
    local hosts
    hosts=$(get_known_hosts)

    if [ -z "$hosts" ]; then
        print_error "No remo environments registered."
        echo ""
        echo "Create one with:"
        echo "  remo aws create"
        echo "  remo hetzner create"
        echo "  remo incus create <name>"
        exit 1
    fi

    local count
    count=$(echo "$hosts" | wc -l)

    local selected
    if [ "$count" -eq 1 ]; then
        selected="$hosts"
    else
        # Use fzf to pick
        if ! command -v fzf &> /dev/null; then
            print_error "Multiple environments found but fzf is not installed."
            echo "Use 'remo <platform> list' to see environments."
            exit 1
        fi

        # Build picker options
        local options=""
        while IFS=: read -r type name host user; do
            local display_name="$name"
            # For incus, show container name without host prefix
            if [ "$type" = "incus" ]; then
                local incus_host="${name%/*}"
                local container="${name#*/}"
                display_name="${container} (on ${incus_host})"
            fi
            options+="${type}: ${display_name} (${host})"$'\n'
        done <<< "$hosts"

        local choice
        choice=$(echo -n "$options" | fzf --prompt="Select environment: " --height=10 --reverse)

        if [ -z "$choice" ]; then
            echo "No selection made."
            exit 0
        fi

        # Find the matching environment by extracting SSH host from choice
        # Format is "type: display_name (ssh_host)"
        local choice_type choice_host
        choice_type=$(echo "$choice" | cut -d: -f1)
        # Extract the last parenthesized value (SSH host)
        choice_host=$(echo "$choice" | grep -oE '\([^)]+\)$' | tr -d '()')

        while IFS=: read -r type name host user; do
            if [ "$type" = "$choice_type" ] && [ "$host" = "$choice_host" ]; then
                selected="${type}:${name}:${host}:${user}"
                break
            fi
        done <<< "$hosts"
    fi

    if [ -z "$selected" ]; then
        print_error "Could not determine environment to connect to."
        exit 1
    fi

    # Parse selected environment
    local type name host user
    IFS=: read -r type name host user <<< "$selected"

    print_info "Connecting to $type: $name ($host)..."
    exec ssh "${user}@${host}"
}

handle_shell() {
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --help|-h)
                show_shell_help
                return 0
                ;;
            -*)
                print_error "Unknown option: $1"
                echo "Run 'remo shell --help' for usage."
                exit 1
                ;;
            *)
                print_error "Unexpected argument: $1"
                exit 1
                ;;
        esac
    done

    shell_connect
}

# =============================================================================
# MAIN ENTRY POINT
# =============================================================================

main() {
    # Load environment variables
    load_env

    local provider="${1:-}"
    shift || true

    case "$provider" in
        init)
            handle_init "$@"
            ;;
        shell)
            handle_shell "$@"
            ;;
        incus)
            handle_incus "$@"
            ;;
        hetzner)
            handle_hetzner "$@"
            ;;
        aws)
            handle_aws "$@"
            ;;
        self-update)
            handle_self_update "$@"
            ;;
        --help|-h|"")
            show_main_help
            ;;
        --version|-v)
            if [ -f "$SCRIPT_DIR/VERSION" ]; then
                echo "remo $(cat "$SCRIPT_DIR/VERSION")"
            else
                echo "remo (version unknown)"
            fi
            ;;
        *)
            print_error "Unknown command: $provider"
            echo "Run 'remo --help' for available commands."
            exit 1
            ;;
    esac
}

main "$@"

#!/bin/bash
# remo - Remote development environment CLI
# Manages Incus containers and Hetzner VMs for development environments

set -e

# Resolve symlinks to find the actual script location
SOURCE="${BASH_SOURCE[0]}"
while [ -h "$SOURCE" ]; do
    SCRIPT_DIR="$(cd -P "$(dirname "$SOURCE")" >/dev/null 2>&1 && pwd)"
    SOURCE="$(readlink "$SOURCE")"
    [[ $SOURCE != /* ]] && SOURCE="$SCRIPT_DIR/$SOURCE"
done
SCRIPT_DIR="$(cd -P "$(dirname "$SOURCE")" >/dev/null 2>&1 && pwd)"
ENV_FILE="$SCRIPT_DIR/.env"
ANSIBLE_DIR="$SCRIPT_DIR/ansible"
VENV_DIR="$SCRIPT_DIR/.venv"

# Config directory - follows XDG spec, can be overridden with REMO_HOME
REMO_HOME="${REMO_HOME:-${XDG_CONFIG_HOME:-$HOME/.config}/remo}"

# Activate virtual environment if it exists
if [ -d "$VENV_DIR" ] && [ -f "$VENV_DIR/bin/activate" ]; then
    source "$VENV_DIR/bin/activate"
fi

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Available tools for --only and --skip options
ALL_TOOLS="docker user_setup nodejs devcontainers github_cli fzf zellij"

# =============================================================================
# UTILITY FUNCTIONS
# =============================================================================

print_error() {
    echo -e "${RED}Error:${NC} $1" >&2
}

print_success() {
    echo -e "${GREEN}$1${NC}"
}

print_info() {
    echo -e "${BLUE}$1${NC}"
}

print_warning() {
    echo -e "${YELLOW}$1${NC}"
}

get_current_version() {
    local git_version
    git_version=$(git -C "$SCRIPT_DIR" describe --tags --exact-match 2>/dev/null)
    if [ -n "$git_version" ]; then
        echo "${git_version#v}"
        return
    fi
    echo "unknown"
}

load_env() {
    if [ -f "$ENV_FILE" ]; then
        while IFS='=' read -r key value; do
            [[ -z "$key" || "$key" =~ ^[[:space:]]*# ]] && continue
            if [[ "$key" =~ ^[A-Za-z_][A-Za-z0-9_]*$ ]]; then
                export "$key=$value"
            fi
        done < "$ENV_FILE"
    fi
}

run_playbook() {
    local playbook="$1"
    shift
    cd "$ANSIBLE_DIR"
    ansible-playbook "$playbook" "$@"
}

# Build extra args for --only and --skip tool filtering
# Usage: build_tool_args only_array_name skip_array_name
# Sets TOOL_EXTRA_ARGS array as output
build_tool_args() {
    local only_name=$1
    local skip_name=$2
    TOOL_EXTRA_ARGS=()

    # Get array sizes using eval (compatible with bash 3.2)
    local only_size
    local skip_size
    eval "only_size=\${#${only_name}[@]}"
    eval "skip_size=\${#${skip_name}[@]}"

    # Handle --only: disable all tools except specified ones
    if [ "$only_size" -gt 0 ]; then
        for tool in $ALL_TOOLS; do
            local enabled="false"
            local i
            for ((i=0; i<only_size; i++)); do
                local val
                eval "val=\${${only_name}[$i]}"
                if [ "$tool" = "$val" ]; then
                    enabled="true"
                    break
                fi
            done
            TOOL_EXTRA_ARGS+=(-e "configure_${tool}=$enabled")
        done
    fi

    # Handle --skip: disable specified tools
    if [ "$skip_size" -gt 0 ]; then
        local i
        for ((i=0; i<skip_size; i++)); do
            local val
            eval "val=\${${skip_name}[$i]}"
            TOOL_EXTRA_ARGS+=(-e "configure_${val}=false")
        done
    fi
}

# =============================================================================
# HELP SYSTEM
# =============================================================================

show_main_help() {
    cat << 'EOF'
remo - Remote development environment CLI

USAGE:
    remo <command> [options]
    remo --help

COMMANDS:
    shell       Connect to a remo environment (auto-detects or picker)
    init        Initialize remo (install dependencies, create .env)
    incus       Manage Incus containers (local or remote host)
    hetzner     Manage Hetzner Cloud VMs
    aws         Manage AWS EC2 instances with EBS storage
    self-update Update remo to a newer version

ENVIRONMENT:
    REMO_HOME   Config directory (default: ~/.config/remo)

EXAMPLES:
    remo shell

    remo incus create dev1
    remo incus list
    remo incus update dev1 --only zellij
    remo incus destroy dev1 --yes
    remo incus bootstrap

    remo hetzner create
    remo hetzner list
    remo hetzner update
    remo hetzner destroy --yes

    remo aws create
    remo aws create --spot
    remo aws list
    remo aws update
    remo aws destroy --yes
    remo aws update-ip

    remo self-update
    remo self-update --pre-release

Run 'remo <command> --help' for command-specific options.
EOF
}

show_init_help() {
    cat << 'EOF'
remo init - Initialize remo environment

USAGE:
    remo init [options]

DESCRIPTION:
    Sets up remo by installing dependencies and creating configuration files.
    Run this once after cloning the repository.

    This command will:
    1. Create a Python virtual environment (.venv)
    2. Install Ansible and hcloud Python packages
    3. Install required Ansible collections
    4. Create .env from .env.example (if not exists)

OPTIONS:
    --force     Recreate venv even if it exists
    --help      Show this help message

EXAMPLES:
    remo init
    remo init --force
EOF
}

# =============================================================================
# INIT COMMAND
# =============================================================================

handle_init() {
    local force="false"

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --force)
                force="true"
                shift
                ;;
            --help|-h)
                show_init_help
                return 0
                ;;
            -*)
                print_error "Unknown option: $1"
                echo "Run 'remo init --help' for usage."
                exit 1
                ;;
            *)
                print_error "Unexpected argument: $1"
                exit 1
                ;;
        esac
    done

    echo ""
    print_info "Initializing remo..."
    echo ""

    # Step 1: Create virtual environment
    if [ -d "$VENV_DIR" ] && [ "$force" = "false" ]; then
        print_success "✓ Virtual environment already exists (.venv)"
    else
        if [ "$force" = "true" ] && [ -d "$VENV_DIR" ]; then
            print_info "Removing existing virtual environment..."
            rm -rf "$VENV_DIR"
        fi
        print_info "Creating virtual environment..."
        python3 -m venv "$VENV_DIR"
        print_success "✓ Created virtual environment (.venv)"
    fi

    # Use venv binaries directly
    local python="$VENV_DIR/bin/python"
    local ansible_galaxy="$VENV_DIR/bin/ansible-galaxy"

    # Step 2: Install Python packages
    # Use uv if available (faster), otherwise use pip
    print_info "Installing Python packages (ansible-core, hcloud, boto3)..."
    if command -v uv &> /dev/null; then
        uv pip install --quiet --python "$python" "ansible-core>=2.18.0,<2.19.0" hcloud boto3 botocore
    else
        # Ensure pip is available
        "$python" -m ensurepip --quiet 2>/dev/null || true
        "$python" -m pip install --quiet --upgrade pip
        "$python" -m pip install --quiet "ansible-core>=2.18.0,<2.19.0" hcloud boto3 botocore
    fi
    print_success "✓ Installed ansible-core, hcloud, and boto3"

    # Step 3: Install Ansible collections
    print_info "Installing Ansible collections..."
    "$ansible_galaxy" collection install --upgrade -r "$ANSIBLE_DIR/requirements.yml" > /dev/null
    print_success "✓ Installed Ansible collections"

    # Step 4: Create .env file
    local env_example="$SCRIPT_DIR/.env.example"
    if [ -f "$ENV_FILE" ]; then
        print_success "✓ Configuration file already exists (.env)"
    elif [ -f "$env_example" ]; then
        cp "$env_example" "$ENV_FILE"
        print_success "✓ Created configuration file (.env)"
    else
        print_warning "⚠ No .env.example found, skipping .env creation"
    fi

    # Print next steps
    echo ""
    print_success "═══════════════════════════════════════════════════════════════"
    print_success "  remo initialized successfully!"
    print_success "═══════════════════════════════════════════════════════════════"
    echo ""

    if [ -f "$ENV_FILE" ]; then
        echo "Next step: Configure your credentials in .env"
        echo ""
        echo -e "  ${YELLOW}For Hetzner Cloud:${NC}"
        echo "    HETZNER_API_TOKEN  - Get from https://console.hetzner.cloud/"
        echo "    DUCKDNS_TOKEN      - Get from https://www.duckdns.org/"
        echo "    DUCKDNS_DOMAIN     - Your subdomain (without .duckdns.org)"
        echo ""
        echo -e "  ${YELLOW}For AWS:${NC}"
        echo "    AWS_ACCESS_KEY_ID      - Get from AWS IAM console"
        echo "    AWS_SECRET_ACCESS_KEY  - Get from AWS IAM console"
        echo "    AWS_REGION             - Optional (default: us-west-2)"
        echo ""
        echo -e "  ${YELLOW}For Incus (local/homelab):${NC}"
        echo "    No credentials needed - uses SSH keys"
        echo ""
        echo "Then run:"
        echo -e "  ${GREEN}./remo incus create dev1 --host <incus-host> --user <user>${NC}"
        echo -e "  ${GREEN}./remo hetzner create${NC}"
        echo -e "  ${GREEN}./remo aws create${NC}"
        echo ""
    fi
}

show_incus_help() {
    cat << 'EOF'
remo incus - Manage Incus containers

USAGE:
    remo incus <command> [options]

COMMANDS:
    create <name>       Create and configure a new container
    destroy <name>      Destroy an existing container
    update <name>       Update dev tools on an existing container
    list                List registered containers
    sync                Discover containers and update registry
    bootstrap           Initialize Incus host (network, storage)

CREATE OPTIONS:
    --domain <domain>   Set container domain (e.g., int.example.com)
    --image <image>     Container image (default: images:ubuntu/24.04/cloud)
    --host <host>       Remote Incus host (default: localhost)
    --user <user>       SSH user for remote host

DESTROY OPTIONS:
    --yes, -y           Skip confirmation prompt
    --host <host>       Remote Incus host (default: localhost)
    --user <user>       SSH user for remote host

UPDATE OPTIONS:
    --only <tool>       Only update specified tool (can repeat)
    --skip <tool>       Skip specified tool (can repeat)
    --host <host>       Remote Incus host (default: localhost)
    --user <user>       SSH user for remote host

    Available tools: docker, user_setup, nodejs, devcontainers, github_cli, fzf, zellij

BOOTSTRAP OPTIONS:
    --host <host>       Remote Incus host (default: localhost)
    --user <user>       SSH user for remote host
    -v, --verbose       Show detailed output

SYNC OPTIONS:
    --host <host>       Remote Incus host (default: localhost)
    --user <user>       SSH user for remote host

    Note: Sync replaces all entries for the specified host.

EXAMPLES:
    remo incus create dev1
    remo incus create dev1 --domain int.get2know.io
    remo incus create dev1 --host 192.168.1.100 --user admin
    remo incus list
    remo incus sync --host 192.168.1.100 --user admin
    remo incus update dev1 --only zellij
    remo incus update dev1 --skip docker --skip nodejs
    remo incus destroy dev1 --yes
    remo incus bootstrap --host myserver.local --user root
EOF
}

show_hetzner_help() {
    cat << 'EOF'
remo hetzner - Manage Hetzner Cloud VMs

USAGE:
    remo hetzner <command> [options]

COMMANDS:
    create              Provision a new Hetzner VM
    update              Update dev tools on an existing VM
    destroy             Tear down a Hetzner VM
    list                List registered Hetzner VMs
    sync                Discover VMs and update registry

CREATE OPTIONS:
    --name <name>       Server name (default: remote-coding-server)
    --type <type>       Server type (default: cx22)
    --location <loc>    Datacenter location (default: hel1)
    --volume-size <GB>  Persistent home volume size in GB (default: 10)

UPDATE OPTIONS:
    --name <name>       Server name (default: remote-coding-server)
    --only <tool>       Only update specified tool (can repeat)
    --skip <tool>       Skip specified tool (can repeat)

    Available tools: docker, user_setup, nodejs, devcontainers, github_cli, fzf, zellij

DESTROY OPTIONS:
    --name <name>       Server name (default: remote-coding-server)
    --yes, -y           Skip confirmation prompt
    --remove-volume     Also remove the persistent volume (DESTROYS DATA!)

NOTES:
    Requires HETZNER_API_TOKEN in .env file or environment.
    The persistent volume is preserved by default on destroy.

EXAMPLES:
    remo hetzner create
    remo hetzner create --name my-server --type cx32
    remo hetzner sync
    remo hetzner update
    remo hetzner update --name my-server --only zellij
    remo hetzner destroy --yes
    remo hetzner destroy --name my-server --yes --remove-volume
EOF
}

# =============================================================================
# KNOWN HOSTS MANAGEMENT
# =============================================================================

KNOWN_HOSTS_FILE="$REMO_HOME/known_hosts"

# Ensure config directory exists
ensure_remo_dir() {
    mkdir -p "$REMO_HOME"
}

# Save a host entry
# Format: TYPE:NAME:HOST:USER[:INSTANCE_ID:ACCESS_MODE[:REGION]]
save_known_host() {
    local type="$1"   # aws, hetzner, incus
    local name="$2"   # instance/container name
    local host="$3"   # hostname or IP to connect to
    local user="$4"   # SSH user (usually remo)
    local instance_id="${5:-}"   # optional: cloud instance ID (e.g., i-abc123)
    local access_mode="${6:-}"   # optional: access mode (direct, ssm)
    local region="${7:-}"        # optional: AWS region (e.g., us-west-2)

    ensure_remo_dir
    touch "$KNOWN_HOSTS_FILE"

    local entry="${type}:${name}:${host}:${user}"
    # Append optional fields only when provided
    if [ -n "$instance_id" ] || [ -n "$access_mode" ]; then
        entry="${entry}:${instance_id:-}:${access_mode:-direct}"
        if [ -n "$region" ]; then
            entry="${entry}:${region}"
        fi
    fi

    # Remove existing entry for this type:name, then add new one
    grep -v "^${type}:${name}:" "$KNOWN_HOSTS_FILE" > "${KNOWN_HOSTS_FILE}.tmp" 2>/dev/null || true
    mv "${KNOWN_HOSTS_FILE}.tmp" "$KNOWN_HOSTS_FILE"
    echo "$entry" >> "$KNOWN_HOSTS_FILE"
}

# Remove a host entry
remove_known_host() {
    local type="$1"
    local name="$2"

    [ ! -f "$KNOWN_HOSTS_FILE" ] && return 0

    grep -v "^${type}:${name}:" "$KNOWN_HOSTS_FILE" > "${KNOWN_HOSTS_FILE}.tmp" 2>/dev/null || true
    mv "${KNOWN_HOSTS_FILE}.tmp" "$KNOWN_HOSTS_FILE"
}

# Get the AWS region for a named instance
# Reads from known_hosts 7th field, falls back to env vars, then us-west-2
get_aws_region() {
    local name="$1"
    local entry region_field

    if [ -f "$KNOWN_HOSTS_FILE" ]; then
        entry=$(grep "^aws:${name}:" "$KNOWN_HOSTS_FILE" 2>/dev/null | head -1) || true
        if [ -n "$entry" ]; then
            region_field=$(echo "$entry" | cut -d: -f7)
            if [ -n "$region_field" ]; then
                echo "$region_field"
                return
            fi
        fi
    fi

    echo "${AWS_REGION:-${AWS_DEFAULT_REGION:-us-west-2}}"
}

# Clear all entries for a given type
clear_known_hosts_by_type() {
    local type="$1"

    [ ! -f "$KNOWN_HOSTS_FILE" ] && return 0

    grep -v "^${type}:" "$KNOWN_HOSTS_FILE" > "${KNOWN_HOSTS_FILE}.tmp" 2>/dev/null || true
    mv "${KNOWN_HOSTS_FILE}.tmp" "$KNOWN_HOSTS_FILE"
}

# Clear all entries for a given type and name prefix (e.g., incus:myhost/*)
clear_known_hosts_by_prefix() {
    local type="$1"
    local prefix="$2"

    [ ! -f "$KNOWN_HOSTS_FILE" ] && return 0

    grep -v "^${type}:${prefix}" "$KNOWN_HOSTS_FILE" > "${KNOWN_HOSTS_FILE}.tmp" 2>/dev/null || true
    mv "${KNOWN_HOSTS_FILE}.tmp" "$KNOWN_HOSTS_FILE"
}

# Get all known hosts (optionally filtered by type)
get_known_hosts() {
    local filter_type="${1:-}"

    [ ! -f "$KNOWN_HOSTS_FILE" ] && return 0

    if [ -n "$filter_type" ]; then
        grep "^${filter_type}:" "$KNOWN_HOSTS_FILE" 2>/dev/null || true
    else
        cat "$KNOWN_HOSTS_FILE" 2>/dev/null || true
    fi
}

# =============================================================================
# INCUS COMMANDS
# =============================================================================

incus_create() {
    local name=""
    local domain=""
    local image=""
    local host="localhost"
    local user=""
    local extra_args=()

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --domain)
                domain="$2"
                shift 2
                ;;
            --image)
                image="$2"
                shift 2
                ;;
            --host)
                host="$2"
                shift 2
                ;;
            --user)
                user="$2"
                shift 2
                ;;
            -*)
                print_error "Unknown option: $1"
                echo "Run 'remo incus --help' for usage."
                exit 1
                ;;
            *)
                if [ -z "$name" ]; then
                    name="$1"
                else
                    print_error "Unexpected argument: $1"
                    exit 1
                fi
                shift
                ;;
        esac
    done

    if [ -z "$name" ]; then
        print_error "Container name is required"
        echo "Usage: remo incus create <name> [options]"
        exit 1
    fi

    print_info "Creating Incus container '$name'..."

    # Build ansible extra vars
    extra_args+=(-e "container_name=$name")

    [ -n "$domain" ] && extra_args+=(-e "container_domain=$domain")
    [ -n "$image" ] && extra_args+=(-e "container_image=$image")

    if [ "$host" != "localhost" ]; then
        extra_args+=(-i "$host,")
        extra_args+=(-e "target_hosts=all")
        [ -n "$user" ] && extra_args+=(-e "incus_host_user=$user")
    fi

    run_playbook incus_site.yml "${extra_args[@]}"

    # Save to known_hosts on success
    # Format: incus:HOST/CONTAINER:CONTAINER:remo
    save_known_host "incus" "${host}/${name}" "$name" "remo"
}

incus_destroy() {
    local name=""
    local auto_confirm="false"
    local host="localhost"
    local user=""
    local extra_args=()

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --yes|-y)
                auto_confirm="true"
                shift
                ;;
            --host)
                host="$2"
                shift 2
                ;;
            --user)
                user="$2"
                shift 2
                ;;
            -*)
                print_error "Unknown option: $1"
                echo "Run 'remo incus --help' for usage."
                exit 1
                ;;
            *)
                if [ -z "$name" ]; then
                    name="$1"
                else
                    print_error "Unexpected argument: $1"
                    exit 1
                fi
                shift
                ;;
        esac
    done

    if [ -z "$name" ]; then
        print_error "Container name is required"
        echo "Usage: remo incus destroy <name> [options]"
        exit 1
    fi

    print_info "Destroying Incus container '$name'..."

    extra_args+=(-e "container_name=$name")
    extra_args+=(-e "auto_confirm=$auto_confirm")

    if [ "$host" != "localhost" ]; then
        extra_args+=(-i "$host,")
        extra_args+=(-e "target_hosts=all")
        [ -n "$user" ] && extra_args+=(-e "incus_host_user=$user")
    fi

    run_playbook incus_teardown.yml "${extra_args[@]}"

    # Remove from known_hosts
    # Format: incus:HOST/CONTAINER:CONTAINER:remo
    remove_known_host "incus" "${host}/${name}"
}

incus_list() {
    echo ""
    printf "%-20s %-20s %-20s %s\n" "CONTAINER" "INCUS HOST" "SSH HOST" "SSH COMMAND"
    printf "%-20s %-20s %-20s %s\n" "---------" "----------" "--------" "-----------"

    while IFS=: read -r type name host user; do
        [ "$type" != "incus" ] && continue
        # name is in format: incus_host/container_name
        local incus_host="${name%/*}"
        local container="${name#*/}"
        printf "%-20s %-20s %-20s %s\n" "$container" "$incus_host" "$host" "ssh ${user}@${host}"
    done < <(get_known_hosts "incus")

    local count
    count=$(get_known_hosts "incus" | wc -l)
    if [ "$count" -eq 0 ]; then
        echo "No Incus containers registered."
        echo ""
        echo "Create one with: remo incus create <name>"
    fi
}

incus_sync() {
    local host="localhost"
    local user=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --host)
                host="$2"
                shift 2
                ;;
            --user)
                user="$2"
                shift 2
                ;;
            -*)
                print_error "Unknown option: $1"
                echo "Run 'remo incus --help' for usage."
                exit 1
                ;;
            *)
                print_error "Unexpected argument: $1"
                exit 1
                ;;
        esac
    done

    print_info "Discovering Incus containers on '$host'..."

    local containers
    local ssh_target="$host"
    [ -n "$user" ] && ssh_target="${user}@${host}"

    if [ "$host" = "localhost" ]; then
        if ! command -v incus &> /dev/null; then
            print_error "incus command not found on localhost"
            return 1
        fi
        containers=$(incus list -f csv -c n 2>&1)
    else
        # Test SSH connection and incus access
        print_info "Connecting as: $ssh_target"
        local test_result
        local ssh_exit
        test_result=$(ssh -o BatchMode=yes -o ConnectTimeout=5 "$ssh_target" "incus list -f csv -c n" 2>&1) && ssh_exit=0 || ssh_exit=$?

        if [ $ssh_exit -eq 255 ]; then
            print_error "SSH connection failed to '$ssh_target'. Check hostname or specify --user."
            return 1
        elif [ $ssh_exit -ne 0 ]; then
            print_error "Failed to run incus on '$host': $test_result"
            return 1
        fi
        containers="$test_result"
    fi

    # Clear existing entries for this host and replace with discovered ones
    clear_known_hosts_by_prefix "incus" "${host}/"

    if [ -z "$containers" ]; then
        print_warning "No Incus containers found on '$host'."
        print_info "Hint: You may need to specify --user if connecting as wrong user."
        return 0
    fi

    local count=0
    while IFS= read -r name; do
        [ -z "$name" ] && continue
        # Format: incus:HOST/CONTAINER:CONTAINER:remo
        save_known_host "incus" "${host}/${name}" "$name" "remo"
        print_success "  Registered: $name"
        ((count++)) || true
    done <<< "$containers"

    echo ""
    print_success "Synced $count Incus container(s) to known_hosts."
}

incus_bootstrap() {
    local host="localhost"
    local user=""
    local verbose=""
    local extra_args=()

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --host)
                host="$2"
                shift 2
                ;;
            --user)
                user="$2"
                shift 2
                ;;
            -v|--verbose)
                verbose="detailed"
                shift
                ;;
            -*)
                print_error "Unknown option: $1"
                echo "Run 'remo incus --help' for usage."
                exit 1
                ;;
            *)
                print_error "Unexpected argument: $1"
                exit 1
                ;;
        esac
    done

    print_info "Bootstrapping Incus host..."

    if [ "$host" != "localhost" ]; then
        extra_args+=(-i "$host,")
        extra_args+=(-e "target_hosts=all")
        [ -n "$user" ] && extra_args+=(-e "ansible_user=$user")
    fi

    [ -n "$verbose" ] && extra_args+=(-e "incus_bootstrap_verbosity=$verbose")

    run_playbook incus_bootstrap.yml "${extra_args[@]}"
}

incus_update() {
    local name=""
    local host="localhost"
    local user=""
    local only=()
    local skip=()
    local extra_args=()

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --host)
                host="$2"
                shift 2
                ;;
            --user)
                user="$2"
                shift 2
                ;;
            --only)
                only+=("$2")
                shift 2
                ;;
            --skip)
                skip+=("$2")
                shift 2
                ;;
            -*)
                print_error "Unknown option: $1"
                echo "Run 'remo incus --help' for usage."
                exit 1
                ;;
            *)
                if [ -z "$name" ]; then
                    name="$1"
                else
                    print_error "Unexpected argument: $1"
                    exit 1
                fi
                shift
                ;;
        esac
    done

    if [ -z "$name" ]; then
        print_error "Container name is required"
        echo "Usage: remo incus update <name> [options]"
        exit 1
    fi

    # Get container IP from Incus host
    print_info "Looking up container '$name'..."
    local container_ip
    local ssh_err
    if [ "$host" = "localhost" ]; then
        container_ip=$(incus list "$name" -f csv -c 4 2>/dev/null | grep -oE '([0-9]{1,3}\.){3}[0-9]{1,3}' | head -1)
    else
        local ssh_target="$host"
        [ -n "$user" ] && ssh_target="${user}@${host}"
        ssh_err=$(ssh -o ConnectTimeout=10 "$ssh_target" "incus list '$name' -f csv -c 4" 2>&1 >/dev/null) || {
            print_error "SSH to '$ssh_target' failed: $ssh_err"
            if [ -z "$user" ]; then
                print_warning "Try specifying --user, e.g.: remo incus update --host $host --user <username> $name"
            fi
            exit 1
        }
        container_ip=$(ssh "$ssh_target" "incus list '$name' -f csv -c 4" 2>/dev/null | grep -oE '([0-9]{1,3}\.){3}[0-9]{1,3}' | head -1)
    fi

    if [ -z "$container_ip" ]; then
        print_error "Could not find IP for container '$name'"
        print_warning "Container may not exist, may be stopped, or may not have an IP yet"
        print_warning "Check with: ssh ${ssh_target:-localhost} 'incus list $name'"
        exit 1
    fi

    print_info "Found container at $container_ip"
    print_info "Configuring container '$name'..."

    extra_args+=(-e "container_ip=$container_ip")

    build_tool_args only skip
    extra_args+=("${TOOL_EXTRA_ARGS[@]}")

    run_playbook incus_configure.yml "${extra_args[@]}"
}

handle_incus() {
    local command="${1:-}"
    shift || true

    case "$command" in
        create)
            incus_create "$@"
            ;;
        destroy)
            incus_destroy "$@"
            ;;
        update)
            incus_update "$@"
            ;;
        list)
            incus_list "$@"
            ;;
        sync)
            incus_sync "$@"
            ;;
        bootstrap)
            incus_bootstrap "$@"
            ;;
        --help|-h|"")
            show_incus_help
            ;;
        *)
            print_error "Unknown incus command: $command"
            echo "Run 'remo incus --help' for available commands."
            exit 1
            ;;
    esac
}

# =============================================================================
# SELF-UPDATE COMMAND
# =============================================================================

show_self_update_help() {
    cat << 'EOF'
remo self-update - Update remo to a newer version

USAGE:
    remo self-update [options]

OPTIONS:
    --version <version>   Update to specific version (e.g., v1.0.0)
    --branch <branch>     Update to latest commit on branch (for development)
    --pre-release         Update to latest pre-release version
    --check               Check for updates without installing
    --help                Show this help message

EXAMPLES:
    remo self-update                    # Update to latest stable
    remo self-update --pre-release      # Update to latest pre-release
    remo self-update --version v1.0.0   # Update to specific version
    remo self-update --branch main      # Update to latest main branch
    remo self-update --check            # Check for available updates
EOF
}

get_latest_release() {
    local include_prerelease="$1"
    local result=""

    # Primary: GitHub Releases API with semver parsing
    local releases
    releases=$(curl -fsSL "https://api.github.com/repos/get2knowio/remo/releases?per_page=20" 2>/dev/null)

    if [ -n "$releases" ]; then
        result=$(echo "$releases" | python3 -c "
import sys, json, re
releases = json.load(sys.stdin)

def version_key(tag):
    m = re.match(r'v?(\d+)\.(\d+)\.(\d+)(?:-rc\.(\d+))?', tag)
    if not m:
        return (0, 0, 0, 0)
    return (int(m.group(1)), int(m.group(2)), int(m.group(3)), int(m.group(4) or 0))

include_pre = '$include_prerelease' == 'true'
best = None
for r in releases:
    if r.get('draft', False):
        continue
    tag = r.get('tag_name', '')
    if not include_pre:
        if r.get('prerelease', False):
            continue
        if '-rc' in tag or '-beta' in tag or '-alpha' in tag:
            continue
    if best is None or version_key(tag) > version_key(best):
        best = tag
if best:
    print(best)
" 2>/dev/null)
    fi

    # Fallback: git tags (in case API is unavailable or parsing fails)
    if [ -z "$result" ]; then
        git -C "$SCRIPT_DIR" fetch --tags origin 2>/dev/null || true
        result=$(git -C "$SCRIPT_DIR" tag -l 'v[0-9]*' 2>/dev/null | python3 -c "
import sys, re
def vkey(t):
    m = re.match(r'v?(\d+)\.(\d+)\.(\d+)(?:-rc\.(\d+))?\s*$', t)
    return (int(m.group(1)),int(m.group(2)),int(m.group(3)),int(m.group(4) or 0)) if m else (0,0,0,0)
include_pre = '$include_prerelease' == 'true'
tags = [t.strip() for t in sys.stdin if t.strip()]
if not include_pre:
    tags = [t for t in tags if '-rc' not in t and '-beta' not in t and '-alpha' not in t]
if tags:
    print(max(tags, key=vkey))
" 2>/dev/null)
    fi

    echo "$result"
}

# Compare two semver strings, returns 0 if $1 > $2 (i.e. $1 is newer)
version_is_newer() {
    python3 -c "
import sys, re
def vkey(v):
    m = re.match(r'v?(\d+)\.(\d+)\.(\d+)(?:-rc\.(\d+))?', v)
    if not m: return (0,0,0,0)
    # rc versions sort below release: rc.N -> N, release -> 999999
    return (int(m.group(1)),int(m.group(2)),int(m.group(3)),int(m.group(4)) if m.group(4) else 999999)
sys.exit(0 if vkey('$1') > vkey('$2') else 1)
" 2>/dev/null
}

# Passive update check with 24-hour cache (non-blocking)
check_for_updates_passive() {
    local current_version
    current_version=$(get_current_version)

    # Skip for dev/branch installs
    [ "$current_version" = "unknown" ] && return 0

    # Detect if user is on a pre-release track
    local include_prerelease="false"
    case "$current_version" in
        *-rc*|*-beta*|*-alpha*) include_prerelease="true" ;;
    esac

    local cache_file="$REMO_HOME/latest_version_cache"
    local cache_ttl=86400  # 24 hours

    # If cache exists and is fresh, check for update hint
    if [ -f "$cache_file" ]; then
        local now file_mtime cache_age
        now=$(date +%s)
        # macOS stat -f %m, Linux stat -c %Y
        file_mtime=$(stat -f %m "$cache_file" 2>/dev/null || stat -c %Y "$cache_file" 2>/dev/null || echo 0)
        cache_age=$((now - file_mtime))

        if [ "$cache_age" -lt "$cache_ttl" ]; then
            # Cache is fresh — show hint only if cached version is actually newer
            local cached_version
            cached_version=$(cat "$cache_file" 2>/dev/null)
            cached_version="${cached_version#v}"
            if [ -n "$cached_version" ] && version_is_newer "$cached_version" "$current_version"; then
                echo ""
                print_info "Update available: v${current_version} → v${cached_version}. Run 'remo self-update' to upgrade."
            fi
            return 0
        fi
    fi

    # Cache is stale or missing — refresh in background
    (
        local latest
        latest=$(get_latest_release "$include_prerelease")
        if [ -n "$latest" ]; then
            ensure_remo_dir
            echo "$latest" > "$cache_file"
        fi
    ) &>/dev/null &
    disown 2>/dev/null
}

handle_self_update() {
    local version=""
    local branch=""
    local pre_release="false"
    local check_only="false"

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --version)
                version="$2"
                shift 2
                ;;
            --branch)
                branch="$2"
                shift 2
                ;;
            --pre-release)
                pre_release="true"
                shift
                ;;
            --check)
                check_only="true"
                shift
                ;;
            --help|-h)
                show_self_update_help
                return 0
                ;;
            -*)
                print_error "Unknown option: $1"
                echo "Run 'remo self-update --help' for usage."
                exit 1
                ;;
            *)
                print_error "Unexpected argument: $1"
                exit 1
                ;;
        esac
    done

    # Get current version
    local current_version
    current_version=$(get_current_version)

    print_info "Current version: ${current_version:-unknown}"

    # Handle branch update separately
    if [ -n "$branch" ]; then
        if [ "$check_only" = "true" ]; then
            print_error "--check is not supported with --branch"
            exit 1
        fi

        echo ""
        print_info "Updating remo to branch: $branch"
        echo ""

        cd "$SCRIPT_DIR"

        print_info "Fetching updates..."
        git fetch origin 2>/dev/null

        print_info "Checking out origin/$branch..."
        git checkout "origin/$branch" 2>/dev/null

        # Re-run init to update dependencies
        print_info "Updating dependencies..."
        ./remo init

        echo ""
        print_success "=============================================="
        print_success "  remo updated to branch: $branch"
        print_success "=============================================="
        echo ""
        rm -f "$REMO_HOME/latest_version_cache"
        return 0
    fi

    # Determine target version
    local target_version=""
    if [ -n "$version" ]; then
        target_version="$version"
    elif [ "$pre_release" = "true" ]; then
        print_info "Checking for latest pre-release..."
        target_version=$(get_latest_release true)
    else
        print_info "Checking for latest stable release..."
        target_version=$(get_latest_release false)
    fi

    if [ -z "$target_version" ]; then
        print_error "Could not determine target version"
        exit 1
    fi

    # Strip 'v' prefix for comparison
    local target_clean="${target_version#v}"
    local current_clean="${current_version#v}"

    print_info "Latest version: $target_version"

    if [ "$target_clean" = "$current_clean" ]; then
        print_success "Already up to date!"
        return 0
    fi

    if [ "$check_only" = "true" ]; then
        echo ""
        print_warning "Update available: $current_version -> $target_version"
        echo "Run 'remo self-update' to install"
        return 0
    fi

    echo ""
    print_info "Updating remo: $current_version -> $target_version"
    echo ""

    # Fetch and checkout the new version
    cd "$SCRIPT_DIR"

    print_info "Fetching updates..."
    git fetch --tags origin 2>/dev/null

    print_info "Checking out $target_version..."
    git checkout "$target_version" 2>/dev/null

    # Re-run init to update dependencies
    print_info "Updating dependencies..."
    ./remo init

    echo ""
    print_success "=============================================="
    print_success "  remo updated to $target_version"
    print_success "=============================================="
    echo ""

    # Clear version cache so passive check doesn't show stale hint
    rm -f "$REMO_HOME/latest_version_cache"

    # Offer to update all known remote hosts
    local hosts
    hosts=$(get_known_hosts)
    if [ -n "$hosts" ]; then
        echo "Known remote hosts:"
        echo ""
        while IFS=: read -r type name _rest; do
            echo "  - ${type}:${name}"
        done <<< "$hosts"
        echo ""
        printf "Update all remote hosts? [y/N] "
        read -r confirm
        if [[ "$confirm" =~ ^[Yy]$ ]]; then
            echo ""
            while IFS=: read -r type name _rest; do
                print_info "Updating ${type}:${name}..."
                case "$type" in
                    aws)
                        aws_update --name "$name" || print_error "Failed to update ${type}:${name}"
                        ;;
                    hetzner)
                        hetzner_update --name "$name" || print_error "Failed to update ${type}:${name}"
                        ;;
                    incus)
                        incus_update "$name" || print_error "Failed to update ${type}:${name}"
                        ;;
                    *)
                        print_warning "Unknown host type: $type (skipping ${name})"
                        ;;
                esac
                echo ""
            done <<< "$hosts"
            print_success "Remote host updates complete."
        fi
    fi
}

# =============================================================================
# HETZNER COMMANDS
# =============================================================================

hetzner_create() {
    local name=""
    local server_type=""
    local location=""
    local volume_size=""
    local extra_args=()

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --name)
                name="$2"
                shift 2
                ;;
            --type)
                server_type="$2"
                shift 2
                ;;
            --location)
                location="$2"
                shift 2
                ;;
            --volume-size)
                volume_size="$2"
                shift 2
                ;;
            -*)
                print_error "Unknown option: $1"
                echo "Run 'remo hetzner --help' for usage."
                exit 1
                ;;
            *)
                print_error "Unexpected argument: $1"
                exit 1
                ;;
        esac
    done

    print_info "Creating Hetzner VM..."

    [ -n "$name" ] && extra_args+=(-e "hetzner_server_name=$name")
    [ -n "$server_type" ] && extra_args+=(-e "hetzner_server_type=$server_type")
    [ -n "$location" ] && extra_args+=(-e "hetzner_location=$location")
    [ -n "$volume_size" ] && extra_args+=(-e "hetzner_volume_size=$volume_size")

    run_playbook hetzner_site.yml "${extra_args[@]}"

    # Save to known_hosts on success
    local server_name="${name:-remote-coding-server}"
    local domain="${DUCKDNS_DOMAIN:-}"
    if [ -n "$domain" ]; then
        save_known_host "hetzner" "$server_name" "${domain}.duckdns.org" "remo"
    fi
}

hetzner_destroy() {
    local name=""
    local auto_confirm="false"
    local remove_volume="false"
    local extra_args=()

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --name)
                name="$2"
                shift 2
                ;;
            --yes|-y)
                auto_confirm="true"
                shift
                ;;
            --remove-volume)
                remove_volume="true"
                shift
                ;;
            -*)
                print_error "Unknown option: $1"
                echo "Run 'remo hetzner --help' for usage."
                exit 1
                ;;
            *)
                print_error "Unexpected argument: $1"
                exit 1
                ;;
        esac
    done

    local server_name="${name:-remote-coding-server}"

    if [ "$remove_volume" = "true" ]; then
        print_warning "WARNING: --remove-volume will destroy all data on the persistent volume!"
    fi

    print_info "Destroying Hetzner VM '$server_name'..."

    [ -n "$name" ] && extra_args+=(-e "hetzner_server_name=$name")
    extra_args+=(-e "auto_confirm=$auto_confirm")
    extra_args+=(-e "remove_volume=$remove_volume")

    run_playbook hetzner_teardown.yml "${extra_args[@]}"

    # Remove from known_hosts
    remove_known_host "hetzner" "$server_name"
}

hetzner_update() {
    local name=""
    local only=()
    local skip=()
    local extra_args=()

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --name)
                name="$2"
                shift 2
                ;;
            --only)
                only+=("$2")
                shift 2
                ;;
            --skip)
                skip+=("$2")
                shift 2
                ;;
            -*)
                print_error "Unknown option: $1"
                echo "Run 'remo hetzner --help' for usage."
                exit 1
                ;;
            *)
                print_error "Unexpected argument: $1"
                exit 1
                ;;
        esac
    done

    local server_name="${name:-remote-coding-server}"

    # Get server IP from DuckDNS domain
    local domain="${DUCKDNS_DOMAIN:-}"
    if [ -z "$domain" ]; then
        print_error "DUCKDNS_DOMAIN not set. Cannot determine server address."
        exit 1
    fi

    local server_host="${domain}.duckdns.org"
    print_info "Updating Hetzner VM '$server_name' at $server_host..."

    build_tool_args only skip
    extra_args+=("${TOOL_EXTRA_ARGS[@]}")

    run_playbook hetzner_configure.yml -i "${server_host}," -e "ansible_user=remo" "${extra_args[@]}"
}

hetzner_list() {
    echo ""
    printf "%-25s %-25s %s\n" "NAME" "HOST" "SSH COMMAND"
    printf "%-25s %-25s %s\n" "----" "----" "-----------"

    while IFS=: read -r type name host user; do
        [ "$type" != "hetzner" ] && continue
        printf "%-25s %-25s %s\n" "$name" "$host" "ssh ${user}@${host}"
    done < <(get_known_hosts "hetzner")

    local count
    count=$(get_known_hosts "hetzner" | wc -l)
    if [ "$count" -eq 0 ]; then
        echo "No Hetzner VMs registered."
        echo ""
        echo "Create one with: remo hetzner create"
    fi
}

hetzner_sync() {
    print_info "Discovering Hetzner VMs..."

    local token="${HETZNER_API_TOKEN:-}"
    if [ -z "$token" ]; then
        print_error "HETZNER_API_TOKEN not set. Cannot query Hetzner API."
        exit 1
    fi

    local domain="${DUCKDNS_DOMAIN:-}"
    if [ -z "$domain" ]; then
        print_error "DUCKDNS_DOMAIN not set. Cannot determine server addresses."
        exit 1
    fi

    # Query Hetzner API for servers with remo label
    local servers
    servers=$(curl -fsSL -H "Authorization: Bearer $token" \
        "https://api.hetzner.cloud/v1/servers?label_selector=remo" 2>/dev/null || true)

    if [ -z "$servers" ]; then
        print_warning "Could not query Hetzner API."
        return 1
    fi

    # Clear existing Hetzner entries and replace with discovered ones
    clear_known_hosts_by_type "hetzner"

    local count=0
    while IFS= read -r name; do
        [ -z "$name" ] && continue
        local host="${domain}.duckdns.org"
        save_known_host "hetzner" "$name" "$host" "remo"
        print_success "  Registered: $name -> $host"
        ((count++)) || true
    done < <(echo "$servers" | python3 -c "
import sys, json
data = json.load(sys.stdin)
for server in data.get('servers', []):
    print(server.get('name', ''))
" 2>/dev/null || true)

    if [ "$count" -eq 0 ]; then
        print_warning "No Hetzner VMs found with 'remo' label."
    else
        echo ""
        print_success "Synced $count Hetzner VM(s) to known_hosts."
    fi
}

handle_hetzner() {
    local command="${1:-}"
    shift || true

    case "$command" in
        create)
            hetzner_create "$@"
            ;;
        update)
            hetzner_update "$@"
            ;;
        destroy)
            hetzner_destroy "$@"
            ;;
        list)
            hetzner_list "$@"
            ;;
        sync)
            hetzner_sync "$@"
            ;;
        --help|-h|"")
            show_hetzner_help
            ;;
        *)
            print_error "Unknown hetzner command: $command"
            echo "Run 'remo hetzner --help' for available commands."
            exit 1
            ;;
    esac
}

# =============================================================================
# AWS COMMANDS
# =============================================================================

show_aws_help() {
    cat << 'EOF'
remo aws - Manage AWS EC2 instances with EBS storage

USAGE:
    remo aws <command> [options]

COMMANDS:
    create              Provision a new AWS EC2 instance
    update              Update dev tools on an existing instance
    destroy             Tear down an AWS EC2 instance
    stop                Stop instance (pause billing, keep storage)
    start               Start a stopped instance
    update-ip           Update security group with current IP
    info                Show instance information
    list                List registered AWS instances
    sync                Discover instances and update registry

CREATE OPTIONS:
    --name <name>       Resource namespace (default: $USER)
    --type <type>       Instance type (default: t3.medium)
    --region <region>   AWS region (default: us-west-2)
    --spot              Use spot instance (cheaper but can be interrupted)
    --dns               Also create Route53 DNS record
    --volume-size <GB>  Persistent home volume size in GB (default: 50)
    --access <mode>     Access mode: 'ssm' (default) or 'direct'
    --iam-profile <name> Use existing IAM instance profile for SSM (skips discovery)

UPDATE OPTIONS:
    --only <tool>       Only update specified tool (can repeat)
    --skip <tool>       Skip specified tool (can repeat)
    --name <name>       Resource namespace (default: $USER)

    Available tools: docker, user_setup, nodejs, devcontainers, github_cli, fzf, zellij

DESTROY OPTIONS:
    --yes, -y           Skip confirmation prompt
    --remove-storage    Also remove the storage volume (DESTROYS DATA!)
    --name <name>       Resource namespace (default: $USER)

STOP OPTIONS:
    --yes, -y           Skip confirmation prompt
    --name <name>       Resource namespace (default: $USER)

START OPTIONS:
    --name <name>       Resource namespace (default: $USER)

UPDATE-IP OPTIONS:
    --name <name>       Resource namespace (default: $USER)

NOTES:
    Requires AWS credentials (via AWS_PROFILE, AWS_ACCESS_KEY_ID, or SSO).
    The storage volume is preserved by default on destroy.
    Resources are namespaced by --name to support multiple users.

CONNECTION:
    After provisioning, connect using:
        remo shell

SSM ACCESS (--access ssm):
    Uses AWS SSM Session Manager instead of direct SSH (default).
    No inbound ports are opened — the SSM agent phones home over HTTPS.

    Prerequisites:
      - session-manager-plugin installed locally
      - IAM instance profile with AmazonSSMManagedInstanceCore policy
        (select existing or let remo create one)

    SSM mode skips:
      - Security group SSH rule (no inbound ports needed)
      - update-ip command (not applicable)
      - Elastic IP and Route53 DNS
      - EBS home volume (uses root volume instead)

EXAMPLES:
    remo aws create
    remo aws create --spot
    remo aws create --name alice --type t3.large
    remo aws create --access ssm
    remo aws create --iam-profile MyCustomSSMProfile
    remo aws create --dns
    remo aws sync
    remo aws update
    remo aws update --only zellij
    remo aws stop
    remo aws stop --yes
    remo aws start
    remo aws destroy --yes
    remo aws destroy --yes --remove-storage
    remo aws update-ip
    remo aws info
EOF
}

select_ssm_instance_profile() {
    local resource_name="$1"
    local region="${2:-us-west-2}"

    # Find IAM instance profiles with SSM policy attached
    local result
    result=$(python3 << PYEOF
import os
import sys
import json

try:
    import boto3
except ImportError:
    print(json.dumps({"error": "boto3 not installed"}))
    sys.exit(0)

region = os.environ.get('AWS_REGION', os.environ.get('AWS_DEFAULT_REGION', '${region}'))
profile_name = os.environ.get('AWS_PROFILE') or None

try:
    session = boto3.Session(region_name=region, profile_name=profile_name)
    iam = session.client('iam')

    # Find roles with AmazonSSMManagedInstanceCore policy
    ssm_policy_arn = 'arn:aws:iam::aws:policy/AmazonSSMManagedInstanceCore'
    list_error = None
    try:
        resp = iam.list_entities_for_policy(PolicyArn=ssm_policy_arn, EntityFilter='Role')
        roles = [r['RoleName'] for r in resp.get('PolicyRoles', [])]
    except Exception as e:
        roles = []
        list_error = f"{type(e).__name__}: {e}"

    # Find instance profiles for each role
    profiles = []
    for role in roles:
        try:
            resp = iam.list_instance_profiles_for_role(RoleName=role)
            for ip in resp.get('InstanceProfiles', []):
                profiles.append({
                    'name': ip['InstanceProfileName'],
                    'role': role,
                    'arn': ip['Arn']
                })
        except Exception:
            pass

    result = {'profiles': profiles}
    if list_error:
        result['error'] = f"Failed to list SSM IAM roles: {list_error}"
    print(json.dumps(result))
except Exception as e:
    print(json.dumps({'error': str(e)}))
PYEOF
)

    if echo "$result" | grep -q '"error"'; then
        local error
        error=$(echo "$result" | python3 -c "import sys,json; print(json.load(sys.stdin).get('error','Unknown'))" 2>/dev/null)
        print_warning "Could not list IAM profiles: $error"
    fi

    local profiles_json
    profiles_json=$(echo "$result" | python3 -c "
import sys, json
data = json.load(sys.stdin)
for p in data.get('profiles', []):
    print(f\"{p['name']}|{p['role']}\")
" 2>/dev/null || true)

    local profile_count=0
    local options=()
    while IFS='|' read -r pname prole; do
        [ -z "$pname" ] && continue
        options+=("$pname (role: $prole)")
        ((profile_count++)) || true
    done <<< "$profiles_json"

    # Add "Create new" option
    options+=("Create new SSM role and profile")

    local selected_profile=""
    local iam_created="false"

    if [ "$profile_count" -eq 1 ]; then
        # Auto-select the only existing profile
        local auto_choice="${options[0]}"
        local auto_name
        auto_name=$(echo "$auto_choice" | cut -d' ' -f1)
        print_info "Auto-selected IAM instance profile: $auto_name"
        selected_profile="$auto_name"
    elif [ "$profile_count" -eq 0 ]; then
        # No existing profiles, go straight to create
        print_info "No existing SSM instance profiles found. Creating one..."
        selected_profile="__create__"
    else
        # Use fzf to pick
        if ! command -v fzf &> /dev/null; then
            print_error "Multiple IAM profiles found but fzf is not installed."
            echo "Available profiles:"
            printf '  %s\n' "${options[@]}"
            exit 1
        fi

        local choice
        choice=$(printf '%s\n' "${options[@]}" | fzf --prompt="Select IAM instance profile: " --height=10 --reverse)

        if [ -z "$choice" ]; then
            echo "No selection made."
            exit 0
        fi

        if [[ "$choice" == "Create new SSM role and profile" ]]; then
            selected_profile="__create__"
        else
            selected_profile=$(echo "$choice" | cut -d' ' -f1)
        fi
    fi

    if [ "$selected_profile" = "__create__" ]; then
        print_info "Creating IAM role and instance profile for SSM..."
        local create_result
        local create_status=0
        create_result=$(python3 << PYEOF
import os
import sys
import json
import time

try:
    import boto3
except ImportError:
    print(json.dumps({"error": "boto3 not installed"}))
    sys.exit(1)

region = os.environ.get('AWS_REGION', os.environ.get('AWS_DEFAULT_REGION', '${region}'))
profile_name = os.environ.get('AWS_PROFILE') or None
resource_name = '${resource_name}'

try:
    session = boto3.Session(region_name=region, profile_name=profile_name)
    iam = session.client('iam')

    role_name = f'remo-{resource_name}-ssm-role'
    ip_name = f'remo-{resource_name}-ssm-profile'

    # Create role with EC2 assume role policy
    assume_role_policy = json.dumps({
        "Version": "2012-10-17",
        "Statement": [{
            "Effect": "Allow",
            "Principal": {"Service": "ec2.amazonaws.com"},
            "Action": "sts:AssumeRole"
        }]
    })

    iam.create_role(
        RoleName=role_name,
        AssumeRolePolicyDocument=assume_role_policy,
        Description='remo SSM Session Manager access role',
        Tags=[
            {'Key': 'remo', 'Value': 'true'},
            {'Key': 'remo_resource_name', 'Value': resource_name}
        ]
    )

    # Attach SSM managed policy
    iam.attach_role_policy(
        RoleName=role_name,
        PolicyArn='arn:aws:iam::aws:policy/AmazonSSMManagedInstanceCore'
    )

    # Create instance profile
    iam.create_instance_profile(
        InstanceProfileName=ip_name,
        Tags=[
            {'Key': 'remo', 'Value': 'true'},
            {'Key': 'remo_resource_name', 'Value': resource_name}
        ]
    )

    # Add role to instance profile
    iam.add_role_to_instance_profile(
        InstanceProfileName=ip_name,
        RoleName=role_name
    )

    # Wait for instance profile to propagate
    time.sleep(10)

    print(json.dumps({'profile_name': ip_name, 'role_name': role_name}))
except Exception as e:
    print(json.dumps({'error': str(e)}))
    sys.exit(1)
PYEOF
) || create_status=$?
        if [ "$create_status" -ne 0 ] && ! echo "$create_result" | grep -q '"error"'; then
            print_error "Failed to create IAM resources (python exit code: $create_status)."
            exit 1
        fi
        if echo "$create_result" | grep -q '"error"'; then
            local error
            error=$(echo "$create_result" | python3 -c "import sys,json; print(json.load(sys.stdin).get('error','Unknown'))" 2>/dev/null || true)
            print_error "Failed to create IAM resources: ${error:-Unknown}"
            echo ""
            echo "You may need to create an IAM instance profile manually with the"
            echo "AmazonSSMManagedInstanceCore policy attached, then re-run with --access ssm."
            exit 1
        fi

        selected_profile=$(echo "$create_result" | python3 -c "import sys,json; print(json.load(sys.stdin).get('profile_name',''))" 2>/dev/null || true)
        if [ -z "$selected_profile" ]; then
            print_error "Failed to determine IAM instance profile name."
            exit 1
        fi
        iam_created="true"
        print_success "Created IAM role and instance profile: $selected_profile"
    fi

    # Return values via globals
    SSM_INSTANCE_PROFILE="$selected_profile"
    SSM_IAM_CREATED="$iam_created"
}

aws_create() {
    local name=""
    local instance_type=""
    local region=""
    local volume_size=""
    local use_spot="false"
    local create_dns="false"
    local access_mode="ssm"
    local iam_profile=""
    local extra_args=()

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --name)
                name="$2"
                shift 2
                ;;
            --type)
                instance_type="$2"
                shift 2
                ;;
            --region)
                region="$2"
                shift 2
                ;;
            --volume-size)
                volume_size="$2"
                shift 2
                ;;
            --spot)
                use_spot="true"
                shift
                ;;
            --dns)
                create_dns="true"
                shift
                ;;
            --access)
                access_mode="$2"
                if [[ "$access_mode" != "direct" && "$access_mode" != "ssm" ]]; then
                    print_error "Invalid access mode: $access_mode (must be 'direct' or 'ssm')"
                    exit 1
                fi
                shift 2
                ;;
            --iam-profile)
                iam_profile="$2"
                shift 2
                ;;
            -*)
                print_error "Unknown option: $1"
                echo "Run 'remo aws --help' for usage."
                exit 1
                ;;
            *)
                print_error "Unexpected argument: $1"
                exit 1
                ;;
        esac
    done

    print_info "Creating AWS EC2 instance..."

    local resource_name="${name:-$USER}"

    # SSM pre-checks
    if [ "$access_mode" = "ssm" ]; then
        if ! command -v session-manager-plugin &> /dev/null; then
            print_error "session-manager-plugin is not installed."
            echo ""
            echo "Install it from:"
            echo "  https://docs.aws.amazon.com/systems-manager/latest/userguide/session-manager-working-with-install-plugin.html"
            echo ""
            echo "On macOS:  brew install --cask session-manager-plugin"
            echo "On Ubuntu: see AWS docs for .deb package"
            exit 1
        fi

        if [ -n "$iam_profile" ]; then
            print_info "Using provided IAM instance profile: $iam_profile"
            SSM_INSTANCE_PROFILE="$iam_profile"
            SSM_IAM_CREATED="false"
        else
            select_ssm_instance_profile "$resource_name" "${region:-us-west-2}"
        fi
        extra_args+=(-e "aws_access_mode=ssm")
        extra_args+=(-e "aws_iam_instance_profile=$SSM_INSTANCE_PROFILE")
        extra_args+=(-e "aws_iam_created=$SSM_IAM_CREATED")
    else
        extra_args+=(-e "aws_access_mode=direct")
    fi

    [ -n "$name" ] && extra_args+=(-e "aws_resource_name=$name")
    [ -n "$instance_type" ] && extra_args+=(-e "aws_instance_type=$instance_type")
    [ -n "$region" ] && extra_args+=(-e "aws_region=$region")
    [ -n "$volume_size" ] && extra_args+=(-e "aws_ebs_size=$volume_size")
    [ "$use_spot" = "true" ] && extra_args+=(-e "aws_use_spot=true")
    [ "$create_dns" = "true" ] && extra_args+=(-e "aws_create_dns=true")

    run_playbook aws_site.yml "${extra_args[@]}"

    # Save to known_hosts on success - get the instance IP and ID
    local instance_info_json
    instance_info_json=$(python3 << EOF
import os
import sys
import json

try:
    import boto3
except ImportError:
    print('{}', file=sys.stderr)
    sys.exit(0)

region = os.environ.get('AWS_REGION', os.environ.get('AWS_DEFAULT_REGION', '${region:-us-west-2}'))
profile = os.environ.get('AWS_PROFILE') or None

try:
    session = boto3.Session(region_name=region, profile_name=profile)
    ec2 = session.client('ec2')
    response = ec2.describe_instances(
        Filters=[
            {'Name': 'tag:Name', 'Values': ['remo-${resource_name}']},
            {'Name': 'tag:remo', 'Values': ['true']},
            {'Name': 'instance-state-name', 'Values': ['running']}
        ]
    )
    for reservation in response.get('Reservations', []):
        for instance in reservation.get('Instances', []):
            ip = instance.get('PublicIpAddress', '')
            instance_id = instance.get('InstanceId', '')
            if ip or instance_id:
                print(json.dumps({'ip': ip, 'instance_id': instance_id}))
                break
except Exception as e:
    print(f'ERROR: {e}', file=sys.stderr)
EOF
)
    local instance_ip instance_id
    instance_ip=$(echo "$instance_info_json" | python3 -c "import sys,json; print(json.load(sys.stdin).get('ip',''))" 2>/dev/null || true)
    instance_id=$(echo "$instance_info_json" | python3 -c "import sys,json; print(json.load(sys.stdin).get('instance_id',''))" 2>/dev/null || true)

    # Compute effective region to store (what was actually used)
    local effective_region="${region:-${AWS_REGION:-${AWS_DEFAULT_REGION:-us-west-2}}}"

    if [ -n "$instance_ip" ] || [ -n "$instance_id" ]; then
        save_known_host "aws" "$resource_name" "${instance_ip:-$instance_id}" "remo" "$instance_id" "$access_mode" "$effective_region"
    else
        print_warning "Could not detect instance IP. Run 'remo aws info' to register the host."
    fi
}

aws_destroy() {
    local auto_confirm="false"
    local remove_storage="false"
    local name=""
    local extra_args=()

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --yes|-y)
                auto_confirm="true"
                shift
                ;;
            --remove-storage)
                remove_storage="true"
                shift
                ;;
            --name)
                name="$2"
                shift 2
                ;;
            -*)
                print_error "Unknown option: $1"
                echo "Run 'remo aws --help' for usage."
                exit 1
                ;;
            *)
                print_error "Unexpected argument: $1"
                exit 1
                ;;
        esac
    done

    if [ "$remove_storage" = "true" ]; then
        print_warning "WARNING: --remove-storage will destroy all data on the storage volume!"
    fi

    print_info "Destroying AWS EC2 instance..."

    local resource_name="${name:-$USER}"
    local region
    region=$(get_aws_region "$resource_name")

    [ -n "$name" ] && extra_args+=(-e "aws_resource_name=$name")
    extra_args+=(-e "auto_confirm=$auto_confirm")
    extra_args+=(-e "remove_storage=$remove_storage")
    extra_args+=(-e "aws_region=$region")

    run_playbook aws_teardown.yml "${extra_args[@]}"

    # Remove from known_hosts
    remove_known_host "aws" "$resource_name"
}

aws_update_ip() {
    local name=""
    local extra_args=()

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --name)
                name="$2"
                shift 2
                ;;
            -*)
                print_error "Unknown option: $1"
                echo "Run 'remo aws --help' for usage."
                exit 1
                ;;
            *)
                print_error "Unexpected argument: $1"
                exit 1
                ;;
        esac
    done

    local resource_name="${name:-$USER}"

    # Check if this instance uses SSM - update-ip is not needed
    local entry
    entry=$(get_known_hosts "aws" | grep "^aws:${resource_name}:" || true)
    if [ -n "$entry" ]; then
        local _t _n _h _u _iid access_mode _region
        IFS=: read -r _t _n _h _u _iid access_mode _region <<< "$entry"
        if [ "${access_mode:-}" = "ssm" ]; then
            print_info "SSM mode — update-ip is not needed (no inbound ports are open)."
            return 0
        fi
    fi

    local region
    region=$(get_aws_region "$resource_name")

    print_info "Updating AWS security group with current IP..."

    [ -n "$name" ] && extra_args+=(-e "aws_resource_name=$name")
    extra_args+=(-e "aws_region=$region")

    run_playbook aws_update_ip.yml "${extra_args[@]}"
}

aws_info() {
    local name=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --name)
                name="$2"
                shift 2
                ;;
            -*)
                print_error "Unknown option: $1"
                echo "Run 'remo aws --help' for usage."
                exit 1
                ;;
            *)
                print_error "Unexpected argument: $1"
                exit 1
                ;;
        esac
    done

    # Use Python with boto3 to get instance info
    local resource_name="${name:-$USER}"
    local region
    region=$(get_aws_region "$resource_name")

    python3 << EOF
import os
import sys

try:
    import boto3
except ImportError:
    print("Error: boto3 is not installed. Run 'remo init' first.", file=sys.stderr)
    sys.exit(1)

region = '${region}'
profile = os.environ.get('AWS_PROFILE') or None

# Use boto3's default credential chain (supports SSO, env vars, IAM roles, etc.)
session = boto3.Session(region_name=region, profile_name=profile)
ec2 = session.client('ec2')

instance_name = "remo-${resource_name}"

response = ec2.describe_instances(
    Filters=[
        {'Name': 'tag:Name', 'Values': [instance_name]},
        {'Name': 'tag:remo', 'Values': ['true']},
        {'Name': 'instance-state-name', 'Values': ['pending', 'running', 'stopping', 'stopped']}
    ]
)

instances = []
for reservation in response.get('Reservations', []):
    instances.extend(reservation.get('Instances', []))

if not instances:
    print(f"No AWS instance found with name: {instance_name}")
    print(f"Run 'remo aws create' to provision a new instance.")
    sys.exit(0)

instance = instances[0]
state = instance.get('State', {}).get('Name', 'unknown')
instance_id = instance.get('InstanceId', 'unknown')
instance_type = instance.get('InstanceType', 'unknown')
public_ip = instance.get('PublicIpAddress', 'N/A')
public_dns = instance.get('PublicDnsName', 'N/A')
launch_time = instance.get('LaunchTime', 'unknown')

tags = {t['Key']: t['Value'] for t in instance.get('Tags', [])}
access_mode = tags.get('remo_access_mode', 'direct')

print(f"""
AWS Instance Information:
========================
Name:          {instance_name}
Instance ID:   {instance_id}
State:         {state}
Type:          {instance_type}
Region:        {region}
Public IP:     {public_ip}
Public DNS:    {public_dns}
Launch Time:   {launch_time}
Access Mode:   {access_mode}
""")

if access_mode == 'ssm':
    print(f"""Connect via SSM:
  remo shell
""")
else:
    print(f"""SSH Connection:
  remo shell
  ssh remo@{public_ip}
""")
EOF

    # Also check/update known_hosts with access mode info
    local entry
    entry=$(get_known_hosts "aws" | grep "^aws:${resource_name}:" || true)
    if [ -z "$entry" ]; then
        # Not registered yet - try to register from AWS info
        local reg_info
        reg_info=$(python3 << EOF
import os, sys, json
try:
    import boto3
except ImportError:
    sys.exit(0)
region = '${region}'
profile = os.environ.get('AWS_PROFILE') or None
session = boto3.Session(region_name=region, profile_name=profile)
ec2 = session.client('ec2')
response = ec2.describe_instances(
    Filters=[
        {'Name': 'tag:Name', 'Values': ['remo-${resource_name}']},
        {'Name': 'tag:remo', 'Values': ['true']},
        {'Name': 'instance-state-name', 'Values': ['running']}
    ]
)
for r in response.get('Reservations', []):
    for inst in r.get('Instances', []):
        ip = inst.get('PublicIpAddress', '')
        iid = inst.get('InstanceId', '')
        tags = {t['Key']: t['Value'] for t in inst.get('Tags', [])}
        am = tags.get('remo_access_mode', 'direct')
        print(json.dumps({'ip': ip, 'instance_id': iid, 'access_mode': am}))
        break
EOF
)
        if [ -n "$reg_info" ]; then
            local r_ip r_iid r_am
            r_ip=$(echo "$reg_info" | python3 -c "import sys,json; print(json.load(sys.stdin).get('ip',''))" 2>/dev/null || true)
            r_iid=$(echo "$reg_info" | python3 -c "import sys,json; print(json.load(sys.stdin).get('instance_id',''))" 2>/dev/null || true)
            r_am=$(echo "$reg_info" | python3 -c "import sys,json; print(json.load(sys.stdin).get('access_mode','direct'))" 2>/dev/null || true)
            if [ -n "$r_ip" ] || [ -n "$r_iid" ]; then
                save_known_host "aws" "$resource_name" "${r_ip:-$r_iid}" "remo" "$r_iid" "$r_am" "$region"
            fi
        fi
    fi
}

aws_stop() {
    local auto_confirm="false"
    local name=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --yes|-y)
                auto_confirm="true"
                shift
                ;;
            --name)
                name="$2"
                shift 2
                ;;
            -*)
                print_error "Unknown option: $1"
                echo "Run 'remo aws --help' for usage."
                exit 1
                ;;
            *)
                print_error "Unexpected argument: $1"
                exit 1
                ;;
        esac
    done

    local resource_name="${name:-$USER}"
    local region
    region=$(get_aws_region "$resource_name")

    # Get instance state
    local state_json
    state_json=$(python3 << EOF
import os, sys, json
try:
    import boto3
except ImportError:
    print(json.dumps({"error": "boto3 not installed. Run 'remo init' first."}))
    sys.exit(0)

region = '${region}'
profile = os.environ.get('AWS_PROFILE') or None
session = boto3.Session(region_name=region, profile_name=profile)
ec2 = session.client('ec2')

response = ec2.describe_instances(
    Filters=[
        {'Name': 'tag:Name', 'Values': ['remo-${resource_name}']},
        {'Name': 'tag:remo', 'Values': ['true']},
        {'Name': 'instance-state-name', 'Values': ['pending', 'running', 'stopping', 'stopped']}
    ]
)
instances = []
for r in response.get('Reservations', []):
    instances.extend(r.get('Instances', []))

if not instances:
    print(json.dumps({"error": "No AWS instance found with name: remo-${resource_name}"}))
    sys.exit(0)

inst = instances[0]
state = inst['State']['Name']
iid = inst['InstanceId']
print(json.dumps({"state": state, "instance_id": iid}))
EOF
)

    # Check for errors
    local err
    err=$(echo "$state_json" | python3 -c "import sys,json; print(json.load(sys.stdin).get('error',''))" 2>/dev/null || true)
    if [ -n "$err" ]; then
        print_error "$err"
        return 1
    fi

    local state instance_id
    state=$(echo "$state_json" | python3 -c "import sys,json; print(json.load(sys.stdin)['state'])" 2>/dev/null)
    instance_id=$(echo "$state_json" | python3 -c "import sys,json; print(json.load(sys.stdin)['instance_id'])" 2>/dev/null)

    if [ "$state" = "stopped" ]; then
        print_info "Instance $instance_id is already stopped."
        return 0
    fi

    if [ "$state" = "stopping" ] || [ "$state" = "pending" ]; then
        print_error "Instance $instance_id is in '$state' state. Wait for it to finish transitioning."
        return 1
    fi

    # Confirm unless --yes
    if [ "$auto_confirm" != "true" ]; then
        echo "This will stop instance $instance_id (remo-${resource_name})."
        echo "Compute billing will stop but EBS storage charges continue."
        echo ""
        read -r -p "Stop this instance? [y/N] " confirm
        if [[ ! "$confirm" =~ ^[Yy]$ ]]; then
            echo "Aborted."
            return 0
        fi
    fi

    print_info "Stopping instance $instance_id..."

    python3 << EOF
import os, sys
try:
    import boto3
except ImportError:
    print("Error: boto3 not installed.", file=sys.stderr)
    sys.exit(1)

region = '${region}'
profile = os.environ.get('AWS_PROFILE') or None
session = boto3.Session(region_name=region, profile_name=profile)
ec2 = session.client('ec2')

ec2.stop_instances(InstanceIds=['${instance_id}'])
print("Waiting for instance to stop...")
waiter = ec2.get_waiter('instance_stopped')
waiter.wait(InstanceIds=['${instance_id}'])
print("Instance stopped.")
EOF

    if [ $? -eq 0 ]; then
        print_success "Instance $instance_id stopped successfully."
    else
        print_error "Failed to stop instance $instance_id."
        return 1
    fi
}

aws_start() {
    local name=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --name)
                name="$2"
                shift 2
                ;;
            -*)
                print_error "Unknown option: $1"
                echo "Run 'remo aws --help' for usage."
                exit 1
                ;;
            *)
                print_error "Unexpected argument: $1"
                exit 1
                ;;
        esac
    done

    local resource_name="${name:-$USER}"
    local region
    region=$(get_aws_region "$resource_name")

    # Get instance state and access mode
    local state_json
    state_json=$(python3 << EOF
import os, sys, json
try:
    import boto3
except ImportError:
    print(json.dumps({"error": "boto3 not installed. Run 'remo init' first."}))
    sys.exit(0)

region = '${region}'
profile = os.environ.get('AWS_PROFILE') or None
session = boto3.Session(region_name=region, profile_name=profile)
ec2 = session.client('ec2')

response = ec2.describe_instances(
    Filters=[
        {'Name': 'tag:Name', 'Values': ['remo-${resource_name}']},
        {'Name': 'tag:remo', 'Values': ['true']},
        {'Name': 'instance-state-name', 'Values': ['pending', 'running', 'stopping', 'stopped']}
    ]
)
instances = []
for r in response.get('Reservations', []):
    instances.extend(r.get('Instances', []))

if not instances:
    print(json.dumps({"error": "No AWS instance found with name: remo-${resource_name}"}))
    sys.exit(0)

inst = instances[0]
state = inst['State']['Name']
iid = inst['InstanceId']
tags = {t['Key']: t['Value'] for t in inst.get('Tags', [])}
access_mode = tags.get('remo_access_mode', 'direct')
print(json.dumps({"state": state, "instance_id": iid, "access_mode": access_mode}))
EOF
)

    # Check for errors
    local err
    err=$(echo "$state_json" | python3 -c "import sys,json; print(json.load(sys.stdin).get('error',''))" 2>/dev/null || true)
    if [ -n "$err" ]; then
        print_error "$err"
        return 1
    fi

    local state instance_id access_mode
    state=$(echo "$state_json" | python3 -c "import sys,json; print(json.load(sys.stdin)['state'])" 2>/dev/null)
    instance_id=$(echo "$state_json" | python3 -c "import sys,json; print(json.load(sys.stdin)['instance_id'])" 2>/dev/null)
    access_mode=$(echo "$state_json" | python3 -c "import sys,json; print(json.load(sys.stdin)['access_mode'])" 2>/dev/null)

    if [ "$state" = "running" ]; then
        print_info "Instance $instance_id is already running."
        return 0
    fi

    if [ "$state" = "stopping" ] || [ "$state" = "pending" ]; then
        print_error "Instance $instance_id is in '$state' state. Wait for it to finish transitioning."
        return 1
    fi

    print_info "Starting instance $instance_id..."

    # Start instance and get new IP
    local start_json
    start_json=$(python3 << EOF
import os, sys, json, time
try:
    import boto3
except ImportError:
    print(json.dumps({"error": "boto3 not installed"}))
    sys.exit(1)

region = '${region}'
profile = os.environ.get('AWS_PROFILE') or None
session = boto3.Session(region_name=region, profile_name=profile)
ec2 = session.client('ec2')

ec2.start_instances(InstanceIds=['${instance_id}'])
print("Waiting for instance to start...", file=sys.stderr)
waiter = ec2.get_waiter('instance_running')
waiter.wait(InstanceIds=['${instance_id}'])

# For SSM mode, wait for SSM agent to come online
access_mode = '${access_mode}'
if access_mode == 'ssm':
    print("Waiting for SSM agent...", file=sys.stderr)
    ssm = session.client('ssm')
    for i in range(30):
        resp = ssm.describe_instance_information(
            Filters=[{'Key': 'InstanceIds', 'Values': ['${instance_id}']}]
        )
        info_list = resp.get('InstanceInformationList', [])
        if info_list and info_list[0].get('PingStatus') == 'Online':
            print("SSM agent online.", file=sys.stderr)
            break
        time.sleep(2)
    else:
        print("WARNING: SSM agent did not come online within 60s. It may need more time.", file=sys.stderr)

# Re-describe to get new public IP
response = ec2.describe_instances(InstanceIds=['${instance_id}'])
inst = response['Reservations'][0]['Instances'][0]
ip = inst.get('PublicIpAddress', '')
print(json.dumps({"ip": ip, "instance_id": "${instance_id}", "access_mode": access_mode}))
EOF
)

    if [ $? -ne 0 ]; then
        print_error "Failed to start instance $instance_id."
        return 1
    fi

    print_success "Instance $instance_id started successfully."

    # Update known_hosts with new IP
    local new_ip
    new_ip=$(echo "$start_json" | python3 -c "import sys,json; print(json.load(sys.stdin).get('ip',''))" 2>/dev/null || true)

    save_known_host "aws" "$resource_name" "${new_ip:-$instance_id}" "remo" "$instance_id" "$access_mode" "$region"

    if [ "$access_mode" = "direct" ] && [ -n "$new_ip" ]; then
        print_info "New public IP: $new_ip"
        print_warning "Run 'remo aws update-ip --name $resource_name' to update the security group."
    fi
}

aws_update() {
    local name=""
    local only=()
    local skip=()
    local extra_args=()

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --name)
                name="$2"
                shift 2
                ;;
            --only)
                only+=("$2")
                shift 2
                ;;
            --skip)
                skip+=("$2")
                shift 2
                ;;
            -*)
                print_error "Unknown option: $1"
                echo "Run 'remo aws --help' for usage."
                exit 1
                ;;
            *)
                print_error "Unexpected argument: $1"
                exit 1
                ;;
        esac
    done

    # Get instance IP and access mode using boto3
    local resource_name="${name:-$USER}"
    local region
    region=$(get_aws_region "$resource_name")
    local update_info
    update_info=$(python3 << EOF
import os
import sys
import json

try:
    import boto3
except ImportError:
    sys.exit(1)

region = '${region}'
profile = os.environ.get('AWS_PROFILE') or None

session = boto3.Session(region_name=region, profile_name=profile)
ec2 = session.client('ec2')

response = ec2.describe_instances(
    Filters=[
        {'Name': 'tag:Name', 'Values': ['remo-${resource_name}']},
        {'Name': 'tag:remo', 'Values': ['true']},
        {'Name': 'instance-state-name', 'Values': ['running']}
    ]
)

instances = []
for reservation in response.get('Reservations', []):
    instances.extend(reservation.get('Instances', []))

if instances:
    inst = instances[0]
    tags = {t['Key']: t['Value'] for t in inst.get('Tags', [])}
    print(json.dumps({
        'ip': inst.get('PublicIpAddress', ''),
        'instance_id': inst.get('InstanceId', ''),
        'access_mode': tags.get('remo_access_mode', 'direct')
    }))
EOF
)

    if [ -z "$update_info" ]; then
        print_error "Could not find running AWS instance for '$resource_name'"
        echo "Run 'remo aws info --name $resource_name' to check instance status."
        exit 1
    fi

    local instance_ip instance_id access_mode
    instance_ip=$(echo "$update_info" | python3 -c "import sys,json; print(json.load(sys.stdin).get('ip',''))" 2>/dev/null || true)
    instance_id=$(echo "$update_info" | python3 -c "import sys,json; print(json.load(sys.stdin).get('instance_id',''))" 2>/dev/null || true)
    access_mode=$(echo "$update_info" | python3 -c "import sys,json; print(json.load(sys.stdin).get('access_mode','direct'))" 2>/dev/null || true)

    if [ -z "$instance_ip" ] && [ "$access_mode" != "ssm" ]; then
        print_error "Could not find running AWS instance for '$resource_name'"
        echo "Run 'remo aws info --name $resource_name' to check instance status."
        exit 1
    fi

    # Update known_hosts with current info
    save_known_host "aws" "$resource_name" "${instance_ip:-$instance_id}" "remo" "$instance_id" "$access_mode" "$region"

    build_tool_args only skip
    extra_args+=("${TOOL_EXTRA_ARGS[@]}")

    if [ "$access_mode" = "ssm" ]; then
        print_info "Updating AWS instance $instance_id via SSM..."
        run_playbook aws_configure.yml \
            -e "aws_access_mode=ssm" \
            -e "aws_instance_id=$instance_id" \
            -e "instance_ip=$instance_id" \
            "${extra_args[@]}"
    else
        print_info "Updating AWS instance at $instance_ip..."
        run_playbook aws_configure.yml -e "instance_ip=$instance_ip" "${extra_args[@]}"
    fi
}

aws_list() {
    echo ""
    printf "%-20s %-20s %-8s %s\n" "NAME" "HOST" "ACCESS" "CONNECT"
    printf "%-20s %-20s %-8s %s\n" "----" "----" "------" "-------"

    while IFS=: read -r type name host user instance_id access_mode region; do
        [ "$type" != "aws" ] && continue
        local mode="${access_mode:-direct}"
        local connect_cmd
        if [ "$mode" = "ssm" ]; then
            connect_cmd="remo shell"
        else
            connect_cmd="ssh ${user}@${host}"
        fi
        printf "%-20s %-20s %-8s %s\n" "$name" "$host" "$mode" "$connect_cmd"
    done < <(get_known_hosts "aws")

    local count
    count=$(get_known_hosts "aws" | wc -l)
    if [ "$count" -eq 0 ]; then
        echo "No AWS instances registered."
        echo ""
        echo "Create one with: remo aws create"
    fi
}

aws_sync() {
    print_info "Discovering AWS instances..."

    local region="${AWS_REGION:-${AWS_DEFAULT_REGION:-us-west-2}}"

    # Query AWS for remo instances
    local result
    result=$(python3 << EOF
import os
import sys
import json

try:
    import boto3
except ImportError:
    print('{"error": "boto3 not installed"}')
    sys.exit(0)

region = os.environ.get('AWS_REGION', os.environ.get('AWS_DEFAULT_REGION', '${region}'))
profile = os.environ.get('AWS_PROFILE') or None

try:
    # Use boto3's default credential chain (supports SSO, env vars, IAM roles, etc.)
    session = boto3.Session(region_name=region, profile_name=profile)
    ec2 = session.client('ec2')
    response = ec2.describe_instances(
        Filters=[
            {'Name': 'tag:remo', 'Values': ['true']},
            {'Name': 'instance-state-name', 'Values': ['running']}
        ]
    )

    instances = []
    for reservation in response.get('Reservations', []):
        for instance in reservation.get('Instances', []):
            tags = {t['Key']: t['Value'] for t in instance.get('Tags', [])}
            name = tags.get('Name', '')
            ip = instance.get('PublicIpAddress', '')
            instance_id = instance.get('InstanceId', '')
            access_mode = tags.get('remo_access_mode', 'direct')
            if name and (ip or instance_id):
                # Strip 'remo-' prefix if present for the resource name
                resource_name = name[5:] if name.startswith('remo-') else name
                instances.append({
                    'name': resource_name,
                    'ip': ip or instance_id,
                    'instance_id': instance_id,
                    'access_mode': access_mode
                })

    print(json.dumps({'instances': instances}))
except Exception as e:
    print(json.dumps({'error': str(e)}))
EOF
)

    if echo "$result" | grep -q '"error"'; then
        local error
        error=$(echo "$result" | python3 -c "import sys,json; print(json.load(sys.stdin).get('error','Unknown error'))" 2>/dev/null)
        print_error "Failed to query AWS: $error"
        return 1
    fi

    # Clear existing AWS entries and replace with discovered ones
    clear_known_hosts_by_type "aws"

    local count=0
    while IFS= read -r line; do
        [ -z "$line" ] && continue
        local s_name s_ip s_instance_id s_access_mode
        s_name=$(echo "$line" | cut -d'|' -f1)
        s_ip=$(echo "$line" | cut -d'|' -f2)
        s_instance_id=$(echo "$line" | cut -d'|' -f3)
        s_access_mode=$(echo "$line" | cut -d'|' -f4)
        [ -z "$s_name" ] || [ -z "$s_ip" ] && continue
        save_known_host "aws" "$s_name" "$s_ip" "remo" "$s_instance_id" "$s_access_mode" "$region"
        local mode_label=""
        [ "${s_access_mode:-direct}" = "ssm" ] && mode_label=" (SSM)"
        print_success "  Registered: $s_name -> ${s_ip}${mode_label}"
        ((count++)) || true
    done < <(echo "$result" | python3 -c "
import sys, json
data = json.load(sys.stdin)
for inst in data.get('instances', []):
    print(f\"{inst['name']}|{inst['ip']}|{inst['instance_id']}|{inst['access_mode']}\")
" 2>/dev/null || true)

    if [ "$count" -eq 0 ]; then
        print_warning "No running AWS instances found with 'remo' tag."
    else
        echo ""
        print_success "Synced $count AWS instance(s) to known_hosts."
    fi
}

handle_aws() {
    local command="${1:-}"
    shift || true

    case "$command" in
        create)
            aws_create "$@"
            ;;
        update)
            aws_update "$@"
            ;;
        destroy)
            aws_destroy "$@"
            ;;
        stop)
            aws_stop "$@"
            ;;
        start)
            aws_start "$@"
            ;;
        update-ip)
            aws_update_ip "$@"
            ;;
        info)
            aws_info "$@"
            ;;
        list)
            aws_list "$@"
            ;;
        sync)
            aws_sync "$@"
            ;;
        --help|-h|"")
            show_aws_help
            ;;
        *)
            print_error "Unknown aws command: $command"
            echo "Run 'remo aws --help' for available commands."
            exit 1
            ;;
    esac
}

# =============================================================================
# SHELL COMMAND
# =============================================================================

show_shell_help() {
    cat << 'EOF'
remo shell - Connect to a remo environment

USAGE:
    remo shell

DESCRIPTION:
    Connects to a registered remo environment:
    - If exactly one environment exists, connects directly
    - If multiple environments exist, shows an interactive picker

    Environments are registered when created with remo <platform> create.
    Use 'remo <platform> list' to see registered environments.

EXAMPLES:
    remo shell              # Connect (or pick if multiple)
    remo aws list           # List AWS instances
    remo hetzner list       # List Hetzner VMs
    remo incus list         # List Incus containers
EOF
}

shell_connect() {
    local hosts
    hosts=$(get_known_hosts)

    if [ -z "$hosts" ]; then
        print_error "No remo environments registered."
        echo ""
        echo "Create one with:"
        echo "  remo aws create"
        echo "  remo hetzner create"
        echo "  remo incus create <name>"
        exit 1
    fi

    local count
    count=$(echo "$hosts" | wc -l)

    local selected
    if [ "$count" -eq 1 ]; then
        selected="$hosts"
    else
        # Use fzf to pick
        if ! command -v fzf &> /dev/null; then
            print_error "Multiple environments found but fzf is not installed."
            echo "Use 'remo <platform> list' to see environments."
            exit 1
        fi

        # Build picker options
        local options=""
        while IFS=: read -r type name host user instance_id access_mode region; do
            local display_name="$name"
            # For incus, show container name without host prefix
            if [ "$type" = "incus" ]; then
                local incus_host="${name%/*}"
                local container="${name#*/}"
                display_name="${container} (on ${incus_host})"
            fi
            local ssm_indicator=""
            if [ "${access_mode:-}" = "ssm" ]; then
                ssm_indicator=" [SSM]"
            fi
            options+="${type}: ${display_name}${ssm_indicator} (${host})"$'\n'
        done <<< "$hosts"

        local choice
        choice=$(echo -n "$options" | fzf --prompt="Select environment: " --height=10 --reverse)

        if [ -z "$choice" ]; then
            echo "No selection made."
            exit 0
        fi

        # Find the matching environment by extracting SSH host from choice
        # Format is "type: display_name [SSM] (ssh_host)"
        local choice_type choice_host
        choice_type=$(echo "$choice" | cut -d: -f1)
        # Extract the last parenthesized value (SSH host)
        choice_host=$(echo "$choice" | grep -oE '\([^)]+\)$' | tr -d '()')

        while IFS=: read -r type name host user _inst_id _acc_mode _region; do
            if [ "$type" = "$choice_type" ] && [ "$host" = "$choice_host" ]; then
                selected="${type}:${name}:${host}:${user}:${_inst_id:-}:${_acc_mode:-}:${_region:-}"
                break
            fi
        done <<< "$hosts"
    fi

    if [ -z "$selected" ]; then
        print_error "Could not determine environment to connect to."
        exit 1
    fi

    # Parse selected environment (supports 4-field, 6-field, and 7-field formats)
    local type name host user instance_id access_mode region
    IFS=: read -r type name host user instance_id access_mode region <<< "$selected"

    # Auto-start stopped AWS instances
    if [ "$type" = "aws" ] && [ -n "${instance_id:-}" ]; then
        local inst_state
        local _effective_region
        _effective_region=$(get_aws_region "$name")
        inst_state=$(python3 << EOF
import os, sys, json
try:
    import boto3
except ImportError:
    sys.exit(0)
region = '${_effective_region}'
profile = os.environ.get('AWS_PROFILE') or None
session = boto3.Session(region_name=region, profile_name=profile)
ec2 = session.client('ec2')
response = ec2.describe_instances(InstanceIds=['${instance_id}'])
for r in response.get('Reservations', []):
    for inst in r.get('Instances', []):
        print(inst['State']['Name'])
        break
EOF
        )
        if [ "${inst_state:-}" = "stopped" ]; then
            print_warning "Instance $instance_id is stopped. Starting it..."
            aws_start --name "$name"
            # Re-read known_hosts for updated IP
            local updated_entry
            updated_entry=$(get_known_hosts "aws" | grep "^aws:${name}:" || true)
            if [ -n "$updated_entry" ]; then
                IFS=: read -r type name host user instance_id access_mode region <<< "$updated_entry"
            fi
        elif [ "${inst_state:-}" = "stopping" ]; then
            print_error "Instance $instance_id is currently stopping. Please wait and try again."
            exit 1
        fi
    fi

    if [ "${access_mode:-}" = "ssm" ]; then
        if ! command -v session-manager-plugin &> /dev/null; then
            print_error "session-manager-plugin is not installed."
            echo ""
            echo "Install it from:"
            echo "  https://docs.aws.amazon.com/systems-manager/latest/userguide/session-manager-working-with-install-plugin.html"
            echo ""
            echo "On macOS:  brew install --cask session-manager-plugin"
            echo "On Ubuntu: see AWS docs for .deb package"
            exit 1
        fi
        print_info "Connecting to $type: $name via SSM (${instance_id})..."
        local _profile="${AWS_PROFILE:-}"
        local _region
        _region=$(get_aws_region "$name")
        local _env_prefix=""
        if [ -n "$_profile" ]; then
            _env_prefix="env AWS_ACCESS_KEY_ID= AWS_SECRET_ACCESS_KEY= AWS_PROFILE=${_profile} "
        fi
        exec ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
            -o ProxyCommand="${_env_prefix}aws ssm start-session --region ${_region} --target %h --document-name AWS-StartSSHSession --parameters 'portNumber=%p'" \
            "${user}@${instance_id}"
    else
        print_info "Connecting to $type: $name ($host)..."
        exec ssh "${user}@${host}"
    fi
}

handle_shell() {
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --help|-h)
                show_shell_help
                return 0
                ;;
            -*)
                print_error "Unknown option: $1"
                echo "Run 'remo shell --help' for usage."
                exit 1
                ;;
            *)
                print_error "Unexpected argument: $1"
                exit 1
                ;;
        esac
    done

    shell_connect
}

# =============================================================================
# MAIN ENTRY POINT
# =============================================================================

main() {
    # Load environment variables
    load_env

    local provider="${1:-}"
    shift || true

    case "$provider" in
        init)
            handle_init "$@"
            ;;
        shell)
            handle_shell "$@"
            ;;
        incus)
            handle_incus "$@"
            ;;
        hetzner)
            handle_hetzner "$@"
            ;;
        aws)
            handle_aws "$@"
            ;;
        self-update)
            handle_self_update "$@"
            ;;
        --help|-h|"")
            show_main_help
            ;;
        --version|-v)
            echo "remo $(get_current_version)"
            ;;
        *)
            print_error "Unknown command: $provider"
            echo "Run 'remo --help' for available commands."
            exit 1
            ;;
    esac

    # Passive update hint (skip for commands where it's noise)
    case "$provider" in
        self-update|--version|-v|--help|-h|"") ;;
        *) check_for_updates_passive ;;
    esac
}

main "$@"
